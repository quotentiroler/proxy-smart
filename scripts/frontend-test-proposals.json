{
  "analysis": "Add comprehensive tests for AuthDebugPanel and storage utilities to improve frontend coverage. The AuthDebugPanel contains multiple flows that interact with storage, session storage, caches and auth store; we mock and spy on the storage and auth store functions and assert UI and side-effect behavior. Also add a small focused test for clearAuthorizationCodeData in storage.ts to verify it deletes session items and calls history.replaceState when URL contains code param. Tests use Vitest + Testing Library patterns consistent with existing tests in the repository.\n\nI will create two new test files:\n- ui/test/components/auth-debug-panel.test.tsx \u2014 tests the AuthDebugPanel component: shows storage status, clears session only, clears caches and triggers logout flow.\n- ui/test/lib/storage.clear-authorization-code.test.ts \u2014 tests clearAuthorizationCodeData utility verifying session cleanup and history.replaceState behavior.\n\nThese tests use spies on '@/lib/storage' and '@/stores/authStore' functions, and safely mock caches and window.location/history where needed. They follow the existing test style (describe/it, userEvent, expect), use async awaits and findBy* queries to handle asynchronous state updates. Confidence: medium-high because module path resolution and JSDOM behaviors are considered; if the test environment resolves module paths differently the mocks may need to be adjusted, but this is aligned with other tests using '@/...' imports.",
  "changes": [
    {
      "action": "create",
      "file": "ui/test/components/auth-debug-panel.test.tsx",
      "search": "",
      "replace": "import React from 'react'\nimport { describe, it, expect, vi, beforeEach, afterEach } from 'vitest'\nimport { render, screen, waitFor } from '@testing-library/react'\nimport userEvent from '@testing-library/user-event'\n\n// Import modules to spy on / stub\nimport * as storage from '@/lib/storage'\nimport * as authStore from '@/stores/authStore'\nimport { AuthDebugPanel } from '@/components/AuthDebugPanel'\n\ndescribe('AuthDebugPanel', () => {\n  const originalCaches = globalThis.caches\n  const originalLocation = globalThis.location\n  let mockLogout = vi.fn()\n\n  beforeEach(() => {\n    vi.restoreAllMocks()\n    // Provide a basic mock for logout in the auth store\n    mockLogout = vi.fn().mockResolvedValue(undefined)\n    vi.spyOn(authStore, 'useAuthStore').mockReturnValue({\n      logout: mockLogout,\n      isAuthenticated: false,\n      error: null\n    } as any)\n\n    // Default storage spies\n    vi.spyOn(storage, 'getItem').mockResolvedValue(null as any)\n    vi.spyOn(storage, 'getSessionItem').mockImplementation((key: string) => null)\n    vi.spyOn(storage, 'removeSessionItem').mockImplementation(() => undefined)\n    vi.spyOn(storage, 'removeItem').mockResolvedValue(undefined)\n    vi.spyOn(storage, 'clearAuthorizationCodeData').mockImplementation(() => undefined)\n\n    // Ensure caches is defined but harmless by default\n    ;(globalThis as any).caches = {\n      keys: async () => [],\n      delete: async () => true,\n    }\n\n    // Mock location to be configurable\n    delete (globalThis as any).location\n    ;(globalThis as any).location = new URL('http://localhost/')\n  })\n\n  afterEach(() => {\n    // restore caches and location\n    ;(globalThis as any).caches = originalCaches\n    ;(globalThis as any).location = originalLocation\n    vi.restoreAllMocks()\n  })\n\n  it('displays storage status when tokens and session data are present', async () => {\n    // getItem returns token data\n    vi.spyOn(storage, 'getItem').mockResolvedValue({ access_token: 'abc' } as any)\n    vi.spyOn(storage, 'getSessionItem').mockImplementation((k: string) => {\n      if (k === 'pkce_code_verifier') return 'verifier'\n      if (k === 'oauth_state') return 'state'\n      return null\n    })\n\n    render(<AuthDebugPanel />)\n\n    // The updateStorageInfo runs in useEffect -> wait for tokens badge to show\n    expect(await screen.findByText('Tokens:')).toBeInTheDocument()\n\n    // Tokens should be reported as Present\n    expect(await screen.findByText(/Present/i)).toBeInTheDocument()\n    // PKCE and OAuth state should be present\n    expect(await screen.findByText('PKCE:')).toBeInTheDocument()\n    expect(await screen.findByText('OAuth State:')).toBeInTheDocument()\n  })\n\n  it('Clear Session Data button calls removeSessionItem and clearAuthorizationCodeData', async () => {\n    const removeSessSpy = vi.spyOn(storage, 'removeSessionItem')\n    const clearAuthCodeSpy = vi.spyOn(storage, 'clearAuthorizationCodeData')\n\n    // Ensure there is some session data initially\n    vi.spyOn(storage, 'getSessionItem').mockImplementation((k: string) => (k === 'pkce_code_verifier' ? 'ver' : 'st'))\n\n    render(<AuthDebugPanel />)\n\n    // Wait for the Refresh Status button to ensure component finished initial update\n    const refreshButton = await screen.findByRole('button', { name: /Refresh Status/i })\n    expect(refreshButton).toBeInTheDocument()\n\n    const user = userEvent.setup()\n    const clearSessionBtn = screen.getByRole('button', { name: /Clear Session Data/i })\n    await user.click(clearSessionBtn)\n\n    // removeSessionItem should have been called for pkce and oauth state\n    expect(removeSessSpy).toHaveBeenCalled()\n    expect(clearAuthCodeSpy).toHaveBeenCalled()\n  })\n\n  it('Clear All Caches calls removeItem, clears localStorage and attempts to reload', async () => {\n    const removeItemSpy = vi.spyOn(storage, 'removeItem').mockResolvedValue(undefined)\n    const localRemoveSpy = vi.spyOn(window.localStorage.__proto__, 'removeItem')\n    const reloadSpy = vi.fn()\n\n    // mock window.location.reload to detect reload calls\n    Object.defineProperty(globalThis, 'location', {\n      value: {\n        ...globalThis.location,\n        reload: reloadSpy,\n      },\n      writable: true,\n    })\n\n    // make caches return a key so deletion path is exercised\n    ;(globalThis as any).caches = {\n      keys: async () => ['cache1'],\n      delete: async (k: string) => true,\n    }\n\n    render(<AuthDebugPanel />)\n\n    const user = userEvent.setup()\n    const clearCachesBtn = await screen.findByRole('button', { name: /Clear All Caches/i })\n    await user.click(clearCachesBtn)\n\n    // removeItem should be called for encrypted storage keys\n    await waitFor(() => {\n      expect(removeItemSpy).toHaveBeenCalled()\n    })\n\n    // localStorage.removeItem should be called for legacy keys\n    expect(localRemoveSpy).toHaveBeenCalled()\n\n    // Because AuthDebugPanel uses setTimeout to call reload, move timers forward if environment supports it\n    // We can't reliably assert reload due to setTimeout in component; we at least verify storage removal calls.\n  })\n\n  it('Force Logout button triggers logout and attempts to change location', async () => {\n    // Ensure logout mock is present\n    const user = userEvent.setup()\n    render(<AuthDebugPanel />)\n\n    const forceBtn = await screen.findByRole('button', { name: /Force Logout & Reset/i })\n    await user.click(forceBtn)\n\n    // logout should be called\n    await waitFor(() => expect(mockLogout).toHaveBeenCalled())\n  })\n})\n",
      "reasoning": "Adds tests for AuthDebugPanel to exercise storage interactions, session clearing, cache clearing and logout behaviors. Uses spies on storage and auth store modules so tests are deterministic and do not rely on real localforage or network. Follows existing test style in the repo.",
      "confidence": "medium"
    },
    {
      "action": "create",
      "file": "ui/test/lib/storage.clear-authorization-code.test.ts",
      "search": "",
      "replace": "import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest'\nimport { clearAuthorizationCodeData } from '@/lib/storage'\n\ndescribe('clearAuthorizationCodeData', () => {\n  const originalLocation = globalThis.location\n  const originalReplaceState = window.history.replaceState\n\n  beforeEach(() => {\n    // Set up sessionStorage with some values\n    sessionStorage.setItem('authorization_code', 'abc')\n    sessionStorage.setItem('oauth_code', 'def')\n    sessionStorage.setItem('auth_code', 'ghi')\n\n    // Mock history.replaceState\n    ;(window.history.replaceState as any) = vi.fn()\n\n    // Make location have a search param so the function will attempt to replace state\n    delete (globalThis as any).location\n    ;(globalThis as any).location = new URL('http://localhost/?code=123')\n  })\n\n  afterEach(() => {\n    // restore location and replaceState\n    ;(globalThis as any).location = originalLocation\n    window.history.replaceState = originalReplaceState\n    sessionStorage.clear()\n    vi.restoreAllMocks()\n  })\n\n  it('removes authorization code session items and clears URL params via replaceState', () => {\n    clearAuthorizationCodeData()\n\n    expect(sessionStorage.getItem('authorization_code')).toBeNull()\n    expect(sessionStorage.getItem('oauth_code')).toBeNull()\n    expect(sessionStorage.getItem('auth_code')).toBeNull()\n\n    // Ensure history.replaceState was called to clear URL params\n    expect(window.history.replaceState).toHaveBeenCalled()\n  })\n\n  it('does not throw when history.replaceState throws (defensive)', () => {\n    // Simulate replaceState throwing\n    (window.history.replaceState as any) = () => { throw new Error('replace failed') }\n\n    expect(() => clearAuthorizationCodeData()).not.toThrow()\n\n    // Session items should still be removed\n    expect(sessionStorage.getItem('authorization_code')).toBeNull()\n  })\n})\n",
      "reasoning": "Adds unit tests for the storage utility clearAuthorizationCodeData. Verifies that sessionStorage entries are removed and that the function attempts to clear URL parameters using history.replaceState. Also tests defensive behavior when replaceState throws. This increases coverage for storage utilities and error handling paths.",
      "confidence": "high"
    }
  ]
}
