{
  "analysis": "Summary: The junior AI suggests adding two new test files around ThemeProvider and useTheme. This direction aligns with the provided existing test patterns, but we should ensure consistency with those patterns and avoid potential brittleness. Improvements made: (1) Use the same error assertion style as existing tests (expect(() => render(...)).toThrow()) instead of manual try/catch, (2) Simplify and stabilize matchMedia mocking with a reusable helper and ensure it gets restored after each test, (3) Avoid depending on an exact localStorage key name by asserting DOM results first; if the implementation uses a different key, tests would fail. However, we can still check localStorage but guard against flakiness by reading from where ThemeProvider likely stores it\u2014assuming 'theme' based on existing examples; we will keep it but ensure cleanup, (4) Remove unnecessary cleanup() calls when unmounting as Testing Library already cleans between tests via Vitest config, but we\u2019ll keep explicit unmount where testing rehydration, (5) Ensure userEvent is awaited properly and default async handling is correct, (6) Keep imports and file placement under ui/test consistent.\n\nAssumptions validated via patterns: existing example tests import from '@/components/theme-provider' and '@/hooks/useTheme', so we mirror these. We align the outside-provider throwing test with the existing style. We also ensure that window.matchMedia is always restored to avoid cross-test pollution.\n\nNet effect: More robust tests, consistent with the repo\u2019s patterns, increasing coverage on a core context/hook with both happy paths and error handling paths.",
  "changes": [
    {
      "action": "create",
      "file": "ui/test/components/theme-provider.behavior.test.tsx",
      "search": "",
      "replace": "import React from 'react'\nimport { describe, it, expect, beforeEach, afterEach, vi } from 'vitest'\nimport { render, screen } from '@testing-library/react'\nimport userEvent from '@testing-library/user-event'\nimport { ThemeProvider } from '@/components/theme-provider'\nimport { useTheme } from '@/hooks/useTheme'\n\nfunction ThemeConsumer() {\n  const { theme, setTheme } = useTheme()\n  return (\n    <div>\n      <div aria-label=\"theme\">{theme}</div>\n      <button onClick={() => setTheme('dark')}>Set Dark</button>\n      <button onClick={() => setTheme('light')}>Set Light</button>\n      <button onClick={() => setTheme('system')}>Set System</button>\n    </div>\n  )\n}\n\n// Utilities to mock and restore matchMedia\nconst originalMatchMedia = window.matchMedia\nconst setupMatchMedia = (prefersDark: boolean) => {\n  const mock = vi.fn().mockImplementation((query: string) => ({\n    matches: prefersDark && query.includes('prefers-color-scheme: dark'),\n    media: query,\n    onchange: null,\n    addListener: vi.fn(),\n    removeListener: vi.fn(),\n    addEventListener: vi.fn(),\n    removeEventListener: vi.fn(),\n    dispatchEvent: vi.fn(),\n  }))\n  Object.defineProperty(window, 'matchMedia', { value: mock, configurable: true })\n  return mock\n}\n\ndescribe('ThemeProvider behavior', () => {\n  beforeEach(() => {\n    localStorage.clear()\n  })\n\n  afterEach(() => {\n    // restore original matchMedia after each test to avoid leakage\n    Object.defineProperty(window, 'matchMedia', { value: originalMatchMedia, configurable: true })\n  })\n\n  it('uses system preference (prefers-color-scheme) when no saved theme', () => {\n    setupMatchMedia(true) // system prefers dark\n\n    render(\n      <ThemeProvider>\n        <ThemeConsumer />\n      </ThemeProvider>\n    )\n\n    const themeEl = screen.getByLabelText('theme')\n    expect(themeEl).toHaveTextContent('dark')\n  })\n\n  it('persists theme to localStorage and rehydrates on remount', async () => {\n    setupMatchMedia(false) // ensure a deterministic non-dark default if implementation uses system\n    const user = userEvent.setup()\n\n    const { unmount } = render(\n      <ThemeProvider>\n        <ThemeConsumer />\n      </ThemeProvider>\n    )\n\n    // Change theme to dark\n    await user.click(screen.getByText('Set Dark'))\n    expect(localStorage.getItem('theme')).toBe('dark')\n\n    // Unmount and remount to verify it picks up saved theme\n    unmount()\n\n    render(\n      <ThemeProvider>\n        <ThemeConsumer />\n      </ThemeProvider>\n    )\n\n    const themeEl = screen.getByLabelText('theme')\n    expect(themeEl).toHaveTextContent('dark')\n  })\n})\n",
      "reasoning": "Improves robustness: consistent error-free matchMedia mocking with restore, aligns with Testing Library best practices, and verifies both system preference and persistence/rehydration flows. Uses toHaveTextContent matcher for clarity and reduces brittle manual cleanup.",
      "confidence": "medium"
    },
    {
      "action": "create",
      "file": "ui/test/hooks/useTheme.integration.test.tsx",
      "search": "",
      "replace": "import React from 'react'\nimport { describe, it, expect } from 'vitest'\nimport { render } from '@testing-library/react'\nimport { ThemeProvider } from '@/components/theme-provider'\nimport { useTheme } from '@/hooks/useTheme'\n\nfunction ConsumerWithoutProvider() {\n  // This usage should throw if hook requires ThemeProvider\n  const { theme } = useTheme()\n  return <div>{theme}</div>\n}\n\ndescribe('useTheme integration', () => {\n  it('throws when used outside of ThemeProvider', () => {\n    expect(() => render(<ConsumerWithoutProvider />)).toThrow()\n  })\n\n  it('works inside ThemeProvider and exposes API', () => {\n    function Consumer() {\n      const { theme, setTheme } = useTheme()\n      return (\n        <div>\n          <div data-testid=\"theme\">{theme}</div>\n          <button onClick={() => setTheme('light')}>light</button>\n        </div>\n      )\n    }\n\n    const { getByTestId } = render(\n      <ThemeProvider>\n        <Consumer />\n      </ThemeProvider>\n    )\n\n    expect(typeof getByTestId('theme').textContent).toBe('string')\n  })\n})\n",
      "reasoning": "Aligns with existing project test style for outside-provider error assertion, and adds a simple inside-provider smoke test to confirm the hook provides theme and setTheme without failing.",
      "confidence": "medium"
    }
  ]
}
