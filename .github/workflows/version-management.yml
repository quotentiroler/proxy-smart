name: Version Management

on:
  workflow_call:
    inputs:
      release_type:
        description: "Type of release (alpha, beta, production)"
        required: true
        type: string
      should_bump_version:
        description: "Whether to bump the version number"
        required: false
        type: boolean
        default: false
      version_suffix:
        description: "Version suffix (alpha, beta, RELEASE)"
        required: true
        type: string
    outputs:
      current_version:
        description: "Current version before any changes"
        value: ${{ jobs.manage.outputs.current_version }}
      new_version:
        description: "New version after processing"
        value: ${{ jobs.manage.outputs.new_version }}
      base_version:
        description: "Base version without suffixes"
        value: ${{ jobs.manage.outputs.base_version }}
      build_number:
        description: "Build number for non-production releases"
        value: ${{ jobs.manage.outputs.build_number }}
      short_sha:
        description: "Short commit SHA"
        value: ${{ jobs.manage.outputs.short_sha }}

jobs:
  manage:
    name: Manage Version
    runs-on: ubuntu-latest
    outputs:
      current_version: ${{ steps.version.outputs.current_version }}
      new_version: ${{ steps.version.outputs.new_version }}
      base_version: ${{ steps.version.outputs.base_version }}
      build_number: ${{ steps.version.outputs.build_number }}
      short_sha: ${{ steps.version.outputs.short_sha }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "22"

      - name: Check if version should be bumped (alpha only)
        id: version_check
        if: inputs.release_type == 'alpha'
        run: |
          # Get current version from current branch
          CURRENT_VERSION=$(node -p "require('./package.json').version")
          echo "current_version=$CURRENT_VERSION" >> $GITHUB_OUTPUT

          # Get version from main branch
          git fetch origin main
          MAIN_VERSION=$(git show origin/main:package.json | node -p "JSON.parse(require('fs').readFileSync('/dev/stdin', 'utf8')).version")
          echo "main_version=$MAIN_VERSION" >> $GITHUB_OUTPUT

          # Remove any existing suffix to get base versions for comparison
          CURRENT_BASE=$(echo "$CURRENT_VERSION" | sed 's/-alpha.*//g' | sed 's/-beta.*//g')
          MAIN_BASE=$(echo "$MAIN_VERSION" | sed 's/-alpha.*//g' | sed 's/-beta.*//g' | sed 's/-RELEASE.*//g')

          echo "current_base=$CURRENT_BASE" >> $GITHUB_OUTPUT
          echo "main_base=$MAIN_BASE" >> $GITHUB_OUTPUT

          # Check if versions match (meaning we should bump)
          if [ "$CURRENT_BASE" = "$MAIN_BASE" ]; then
            echo "should_bump=true" >> $GITHUB_OUTPUT
            echo "✅ Versions match ($CURRENT_BASE = $MAIN_BASE) - will bump version"
          else
            echo "should_bump=false" >> $GITHUB_OUTPUT
            echo "⏭️  Versions differ ($CURRENT_BASE ≠ $MAIN_BASE) - will use current version"
          fi

      - name: Determine version
        id: version
        run: |
          CURRENT_VERSION=$(node -p "require('./package.json').version")
          # Remove any existing suffix to get the base version
          BASE_VERSION=$(echo "$CURRENT_VERSION" | sed 's/-alpha.*//g' | sed 's/-beta.*//g' | sed 's/-RELEASE.*//g')
          
          echo "base_version=$BASE_VERSION" >> $GITHUB_OUTPUT
          echo "current_version=$CURRENT_VERSION" >> $GITHUB_OUTPUT

          # Generate build info for non-production releases
          if [ "${{ inputs.release_type }}" != "production" ]; then
            SHORT_SHA=$(git rev-parse --short HEAD)
            BUILD_NUMBER=$(date +%Y%m%d%H%M)
            echo "short_sha=$SHORT_SHA" >> $GITHUB_OUTPUT
            echo "build_number=$BUILD_NUMBER" >> $GITHUB_OUTPUT
          fi

          # Determine new version based on release type and bump requirements
          case "${{ inputs.release_type }}" in
            "alpha")
              if [ "${{ inputs.should_bump_version }}" = "true" ] && [ "${{ steps.version_check.outputs.should_bump }}" = "true" ]; then
                # Bump patch version for alpha
                NEW_BASE=$(echo "$BASE_VERSION" | awk -F. '{$NF = $NF + 1; print}' | sed 's/ /./g')
                NEW_VERSION="${NEW_BASE}-${{ inputs.version_suffix }}.${BUILD_NUMBER}.${SHORT_SHA}"
              else
                NEW_VERSION="${BASE_VERSION}-${{ inputs.version_suffix }}.${BUILD_NUMBER}.${SHORT_SHA}"
              fi
              ;;
            "beta")
              NEW_VERSION="${BASE_VERSION}-${{ inputs.version_suffix }}.${BUILD_NUMBER}.${SHORT_SHA}"
              ;;
            "production")
              NEW_VERSION="${BASE_VERSION}"
              ;;
            *)
              echo "❌ Unknown release type: ${{ inputs.release_type }}"
              exit 1
              ;;
          esac

          echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "Final version: $NEW_VERSION"

      - name: Update versions in all packages
        run: |
          # Set the new version in all packages
          node scripts/version.js set ${{ steps.version.outputs.new_version }}
          # Sync to ensure all packages are consistent
          npm run version:sync
          
          # Verify versions are now consistent
          echo "Verifying version consistency:"
          for file in package.json backend/package.json ui/package.json test/package.json; do
            if [ -f "$file" ]; then
              version=$(node -p "require('./$file').version")
              echo "$file: $version"
            fi
          done

      - name: Update README version badge
        run: |
          # Update version badge in README.md
          if [ -f "README.md" ]; then
            sed -i "s/version-[0-9]\+\.[0-9]\+\.[0-9]\+\(-[a-zA-Z0-9\.-]*\)\?-blue/version-${{ steps.version.outputs.new_version }}-blue/g" README.md
            echo "Updated README.md version badge to ${{ steps.version.outputs.new_version }}"
          fi
