name: Release Template

on:
  workflow_call:
    inputs:
      release_type:
        description: "Type of release (alpha, beta, production)"
        required: true
        type: string
      source_branch:
        description: "Source branch for the release"
        required: true
        type: string
      target_branch:
        description: "Target branch to push changes to"
        required: true
        type: string
      version_suffix:
        description: "Version suffix (alpha, beta, RELEASE)"
        required: true
        type: string
      should_bump_version:
        description: "Whether to bump the version number"
        required: false
        type: boolean
        default: false
      is_prerelease:
        description: "Whether this is a prerelease"
        required: false
        type: boolean
        default: false
      commit_limit:
        description: "Number of commits to check for changelog"
        required: false
        type: number
        default: 10
    secrets:
      OPENAI_API_KEY:
        required: false

jobs:
  release:
    name: Create ${{ inputs.release_type }} Release
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "22"

      - name: Setup Bun
        uses: oven-sh/setup-bun@v1
        with:
          bun-version: latest

      - name: Configure git
        run: |
          git config --global user.name 'github-actions[bot]'
          git config --global user.email 'github-actions[bot]@users.noreply.github.com'

      - name: Check if version should be bumped (alpha only)
        id: version_check
        if: inputs.release_type == 'alpha'
        run: |
          # Get current version from develop branch
          DEVELOP_VERSION=$(node -p "require('./package.json').version")
          echo "develop_version=$DEVELOP_VERSION" >> $GITHUB_OUTPUT

          # Get version from main branch
          git fetch origin main
          MAIN_VERSION=$(git show origin/main:package.json | node -p "JSON.parse(require('fs').readFileSync('/dev/stdin', 'utf8')).version")
          echo "main_version=$MAIN_VERSION" >> $GITHUB_OUTPUT

          # Remove any existing suffix to get base versions for comparison
          DEVELOP_BASE=$(echo "$DEVELOP_VERSION" | sed 's/-alpha.*//g' | sed 's/-beta.*//g')
          MAIN_BASE=$(echo "$MAIN_VERSION" | sed 's/-alpha.*//g' | sed 's/-beta.*//g' | sed 's/-RELEASE.*//g')

          echo "develop_base=$DEVELOP_BASE" >> $GITHUB_OUTPUT
          echo "main_base=$MAIN_BASE" >> $GITHUB_OUTPUT

          # Check if versions match (meaning we should bump)
          if [ "$DEVELOP_BASE" = "$MAIN_BASE" ]; then
            echo "should_bump=true" >> $GITHUB_OUTPUT
            echo "‚úÖ Versions match ($DEVELOP_BASE = $MAIN_BASE) - will bump version"
          else
            echo "should_bump=false" >> $GITHUB_OUTPUT
            echo "‚è≠Ô∏è  Versions differ ($DEVELOP_BASE ‚â† $MAIN_BASE) - will use current version"
          fi

      - name: Determine version
        id: version
        run: |
          CURRENT_VERSION=$(node -p "require('./package.json').version")
          # Remove any existing suffix to get the base version
          BASE_VERSION=$(echo "$CURRENT_VERSION" | sed 's/-alpha.*//g' | sed 's/-beta.*//g' | sed 's/-RELEASE.*//g')
          echo "base_version=$BASE_VERSION" >> $GITHUB_OUTPUT
          echo "current_version=$CURRENT_VERSION" >> $GITHUB_OUTPUT

          # Generate build info for non-production releases
          if [ "${{ inputs.release_type }}" != "production" ]; then
            BUILD_NUMBER=$(date +%Y%m%d%H%M%S)
            SHORT_SHA=$(git rev-parse --short HEAD)
            echo "build_number=$BUILD_NUMBER" >> $GITHUB_OUTPUT
            echo "short_sha=$SHORT_SHA" >> $GITHUB_OUTPUT
          fi

          # Determine new version based on release type
          case "${{ inputs.release_type }}" in
            "alpha")
              # Check if we should bump version for alpha
              if [ "${{ steps.version_check.outputs.should_bump }}" = "true" ]; then
                IFS='.' read -r major minor patch <<< "$BASE_VERSION"
                NEW_BASE_VERSION="$major.$minor.$((patch + 1))"
                echo "üîÑ Bumping version: $BASE_VERSION ‚Üí $NEW_BASE_VERSION"
              else
                NEW_BASE_VERSION="$BASE_VERSION"
                echo "üìå Using current version: $BASE_VERSION"
              fi
              NEW_VERSION="$NEW_BASE_VERSION-${{ inputs.version_suffix }}.$BUILD_NUMBER+$SHORT_SHA"
              ;;
            "beta")
              NEW_VERSION="$BASE_VERSION-${{ inputs.version_suffix }}.$BUILD_NUMBER+$SHORT_SHA"
              ;;
            "production")
              NEW_VERSION="$BASE_VERSION-${{ inputs.version_suffix }}"
              ;;
          esac

          echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "Final version: $NEW_VERSION"

      - name: Update versions
        run: |
          # Set the new version in all packages
          node scripts/version.js set ${{ steps.version.outputs.new_version }}
          # Sync to ensure all packages are consistent
          npm run version:sync
          # Verify versions are now consistent
          echo "Verifying version consistency:"
          for file in package.json backend/package.json ui/package.json test/package.json; do
            if [ -f "$file" ]; then
              VERSION=$(node -p "require('./$file').version")
              echo "$file: $VERSION"
            fi
          done

      - name: Update README version badge
        run: |
          # Update version badge in README.md
          sed -i "s/version-[0-9]\+\.[0-9]\+\.[0-9]\+\(-[a-zA-Z0-9\.-]*\)\?-blue/version-${{ steps.version.outputs.new_version }}-blue/g" README.md
          echo "Updated README.md version badge to ${{ steps.version.outputs.new_version }}"

      - name: Build all projects
        run: |
          echo "Building all projects..."

          # Build backend
          echo "Building backend..."
          cd backend
          bun install
          bun run build
          cd ..

          # Build UI
          echo "Building UI..."
          cd ui
          bun install
          bun run build
          cd ..

          # Install test dependencies
          echo "Installing test dependencies..."
          cd test
          bun install
          cd ..

      - name: Run tests
        run: |
          echo "Running tests..."
          cd test
          bun run test || echo "Tests failed, but continuing with release"
          cd ..

      - name: Get commit SHAs for this PR
        id: pr_commits
        run: |
          # Find the PR that was merged to trigger this push
          echo "Looking for PR associated with this push..."

          # Try to find PR number from the push event or recent merge commit
          PR_NUM=""

          # Method 1: Check if this push was from a merged PR by looking at recent commits
          RECENT_COMMIT_MSG=$(git log --format="%s" -n 1)
          if echo "$RECENT_COMMIT_MSG" | grep -E "Merge pull request #[0-9]+" > /dev/null; then
            PR_NUM=$(echo "$RECENT_COMMIT_MSG" | grep -oE "#[0-9]+" | sed 's/#//')
            echo "Found PR number from merge commit: $PR_NUM"
          fi

          # Method 2: Use GitHub API to find PRs that were merged recently
          if [ -z "$PR_NUM" ]; then
            echo "Searching for recently merged PRs..."
            PR_NUM=$(gh api repos/${{ github.repository }}/pulls \
              --field state=closed \
              --field base=${{ inputs.source_branch }} \
              --field sort=updated \
              --field direction=desc \
              --jq '.[] | select(.merged_at != null) | select(.merge_commit_sha == "'${{ github.sha }}'") | .number' \
              | head -n1)
          fi

          if [ -n "$PR_NUM" ]; then
            echo "Found PR #$PR_NUM"
            # Get the exact commits that were in this PR
            COMMITS=$(gh pr view "$PR_NUM" --repo "${{ github.repository }}" \
              --json commits --jq '.commits[].oid' | tr '\n' ' ')
            echo "commits=$COMMITS" >> $GITHUB_OUTPUT
            echo "pr_number=$PR_NUM" >> $GITHUB_OUTPUT
            echo "Found commits in PR #$PR_NUM"
          else
            echo "No PR found for this push"
            echo "commits=" >> $GITHUB_OUTPUT
            echo "pr_number=" >> $GITHUB_OUTPUT
          fi

      - name: Generate changelog
        id: changelog
        shell: bash
        run: |
          set -euo pipefail
          ALL_SHAS="${{ steps.pr_commits.outputs.commits }}"
          if [ -z "$ALL_SHAS" ]; then
            LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
            if [ -n "$LAST_TAG" ]; then
              echo "‚ö†Ô∏è  No PR found ‚Äì using commits since $LAST_TAG"
              ALL_SHAS=$(
                git rev-list \
                  --no-merges --reverse \
                  --max-count=${{ inputs.commit_limit }} \
                  $LAST_TAG..HEAD \
                  | tr '\n' ' '
              )
            else
              echo "‚ö†Ô∏è  No tags found ‚Äì falling back to recent commits"
              ALL_SHAS=$(
                git rev-list \
                  --no-merges --reverse \
                  --max-count=${{ inputs.commit_limit }} \
                  HEAD \
                  | tr '\n' ' '
              )
            fi
          fi
          echo "Using SHAs: $ALL_SHAS"
          # ‚Ä¶rest of your changelog generation‚Ä¶
          # Function to get AI summary of commit comments
          get_ai_summary() {
            local commits="$1"
            local all_comments=""
            
            for sha in $commits; do
              if [ -n "$sha" ]; then
                commit_msg=$(git log --format="%s" -n 1 $sha)
                echo "Processing commit $sha: $commit_msg"
                
                # Try multiple methods to get commit comments
                ai_comment=""
                
                # Method 1: Get commit comments via API
                api_comments=$(gh api repos/${{ github.repository }}/commits/$sha/comments --jq '.[].body // empty' 2>/dev/null | head -1 || echo "")
                
                # Method 2: If no API comments, try getting comments from the commit page
                if [ -z "$api_comments" ]; then
                  # Try to get comments from the commit URL directly
                  commit_page=$(gh api repos/${{ github.repository }}/commits/$sha --jq '.html_url' 2>/dev/null || echo "")
                  if [ -n "$commit_page" ]; then
                    echo "Checking commit page: $commit_page"
                    # Get all comments for this commit via the API with more details
                    detailed_comments=$(gh api repos/${{ github.repository }}/commits/$sha/comments --jq '.[] | "\(.body)\n---\n"' 2>/dev/null || echo "")
                    if [ -n "$detailed_comments" ]; then
                      api_comments="$detailed_comments"
                    fi
                  fi
                fi
                
                # Method 3: Fallback - use commit message if it's descriptive enough
                if [ -z "$api_comments" ] && [ ${#commit_msg} -gt 10 ] && [ "$commit_msg" != "Update" ] && [ "$commit_msg" != "update" ]; then
                  api_comments="$commit_msg"
                fi
                
                ai_comment="$api_comments"
                
                if [ -n "$ai_comment" ] && [ "$ai_comment" != "" ]; then
                  all_comments="${all_comments}**${commit_msg}**: ${ai_comment}\n\n"
                  echo "‚úÖ Found comment for commit $sha"
                else
                  echo "‚ùå No comment found for commit $sha: $commit_msg"
                  # Still include the commit message for context
                  all_comments="${all_comments}**${commit_msg}**: [No detailed description available]\n\n"
                fi
              fi
            done
            
            if [ -n "$all_comments" ] && [ "$all_comments" != "" ]; then
              if [ -n "${{ secrets.OPENAI_API_KEY }}" ]; then
                echo "Generating AI summary from collected comments..."
                # Use OpenAI to summarize the commit comments into concise changelog entries
                summary=$(curl -s -X POST "https://api.openai.com/v1/chat/completions" \
                  -H "Authorization: Bearer ${{ secrets.OPENAI_API_KEY }}" \
                  -H "Content-Type: application/json" \
                  -d '{
                    "model": "gpt-4o-mini",
                    "messages": [
                      {
                        "role": "system",
                        "content": "You are a technical writer creating concise changelog entries. Summarize the provided commit information into bullet points that highlight the key changes, features, fixes, and improvements. Each bullet should be clear, concise (1-2 lines max), and focus on user-facing changes. Use action verbs and be specific about what changed. If a commit has \"[No detailed description available]\", infer the likely changes from the commit message."
                      },
                      {
                        "role": "user", 
                        "content": "Summarize these commit entries into concise changelog entries:\n\n'"$all_comments"'"
                      }
                    ],
                    "max_tokens": 500,
                    "temperature": 0.3
                  }' | jq -r '.choices[0].message.content // "- Unable to generate summary"')
                
                if [ "$summary" = "- Unable to generate summary" ] || [ -z "$summary" ]; then
                  echo "‚ö†Ô∏è  OpenAI summary failed, using commit messages directly"
                  # Fallback to basic formatting of commit messages
                  summary=$(echo -e "$all_comments" | sed 's/\*\*\([^:]*\)\*\*:/- \1:/' | sed 's/\[No detailed description available\]//' | grep -v '^$')
                fi
              else
                echo "‚ö†Ô∏è  No OpenAI API key provided, using commit messages directly"
                # Fallback to basic formatting of commit messages
                summary=$(echo -e "$all_comments" | sed 's/\*\*\([^:]*\)\*\*:/- \1:/' | sed 's/\[No detailed description available\]//' | grep -v '^$')
              fi
              
              echo "$summary"
            else
              echo "- No commits with meaningful descriptions found in this release"
            fi
          }

          # Generate changelog
          CHANGELOG=$(get_ai_summary "$ALL_SHAS")

          # Create changelog file for production releases
          if [ "${{ inputs.release_type }}" = "production" ]; then
            cat > CHANGELOG.md << EOF
          # Changelog

          ## [v${{ steps.version.outputs.new_version }}] - $(date +%Y-%m-%d)

          ### Changes
          $CHANGELOG

          EOF
          fi

          # Save changelog for release notes
          echo "changelog<<EOF" >> $GITHUB_OUTPUT
          case "${{ inputs.release_type }}" in
            "alpha")
              if [ "${{ steps.version_check.outputs.should_bump }}" = "true" ]; then
                echo "### Changes in v${{ steps.version.outputs.new_version }} (Alpha - Version Bumped)" >> $GITHUB_OUTPUT
              else
                echo "### Changes in v${{ steps.version.outputs.new_version }} (Alpha)" >> $GITHUB_OUTPUT
              fi
              ;;
            "beta")
              echo "### Changes in v${{ steps.version.outputs.new_version }} (Beta)" >> $GITHUB_OUTPUT
              ;;
            "production")
              echo "### Changes in v${{ steps.version.outputs.new_version }} (Production)" >> $GITHUB_OUTPUT
              ;;
          esac
          echo "" >> $GITHUB_OUTPUT
          echo "$CHANGELOG" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Commit version updates
        run: |
          case "${{ inputs.release_type }}" in
            "alpha")
              if [ "${{ steps.version_check.outputs.should_bump }}" = "true" ]; then
                COMMIT_MSG="chore: bump version and create ${{ inputs.release_type }} build ${{ steps.version.outputs.new_version }} [skip ci]"
              else
                COMMIT_MSG="chore: ${{ inputs.release_type }} build ${{ steps.version.outputs.new_version }} [skip ci]"
              fi
              ;;
            "beta")
              COMMIT_MSG="chore: ${{ inputs.release_type }} build ${{ steps.version.outputs.new_version }} [skip ci]"
              ;;
            "production")
              COMMIT_MSG="chore: ${{ inputs.release_type }} release ${{ steps.version.outputs.new_version }} [skip ci]"
              ;;
          esac

          if [ "${{ inputs.release_type }}" = "production" ]; then
            git add package.json backend/package.json ui/package.json test/package.json CHANGELOG.md README.md
          else
            git add package.json backend/package.json ui/package.json test/package.json README.md
          fi
          git commit -m "$COMMIT_MSG"
          git push origin ${{ inputs.target_branch }}

      - name: Create and push tag
        run: |
          git tag "v${{ steps.version.outputs.new_version }}"
          git push origin "v${{ steps.version.outputs.new_version }}"

      - name: Create GitHub Release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          tag: v${{ steps.version.outputs.new_version }}
        run: |
          # Create release notes content
          case "${{ inputs.release_type }}" in
            "alpha")
              cat > release_notes.md << 'EOF'
          # SMART on FHIR Proxy v${{ steps.version.outputs.new_version }} (Alpha)

          ‚ö†Ô∏è **This is an alpha release** - Use with caution in development environments only.

          **Build Info:**
          - Build Number: ${{ steps.version.outputs.build_number }}
          - Commit: ${{ steps.version.outputs.short_sha }}
          - Built from: `${{ inputs.source_branch }}` branch

          ${{ steps.changelog.outputs.changelog }}

          ## Components
          - **Backend**: SMART on FHIR Proxy Server
          - **UI**: Administration Interface  
          - **Test Suite**: Comprehensive FHIR compliance tests

          ## Installation
          ```bash
          git clone https://github.com/${{ github.repository }}.git
          cd smart-on-fhir-proxy
          git checkout v${{ steps.version.outputs.new_version }}
          ```

          See the [README](README.md) for setup instructions.
          EOF
              ;;
            "beta")
              cat > release_notes.md << 'EOF'
          # SMART on FHIR Proxy v${{ steps.version.outputs.new_version }} (Beta)

          üß™ **This is a beta release** - Suitable for testing and staging environments.

          **Build Info:**
          - Build Number: ${{ steps.version.outputs.build_number }}
          - Commit: ${{ steps.version.outputs.short_sha }}
          - Built from: `${{ inputs.source_branch }}` branch

          ${{ steps.changelog.outputs.changelog }}

          ## Components
          - **Backend**: SMART on FHIR Proxy Server
          - **UI**: Administration Interface  
          - **Test Suite**: Comprehensive FHIR compliance tests

          ## Installation
          ```bash
          git clone https://github.com/${{ github.repository }}.git
          cd smart-on-fhir-proxy
          git checkout v${{ steps.version.outputs.new_version }}
          ```

          See the [README](README.md) for setup instructions.
          EOF
              ;;
            "production")
              cat > release_notes.md << 'EOF'
          # SMART on FHIR Proxy v${{ steps.version.outputs.new_version }}

          ${{ steps.changelog.outputs.changelog }}

          ## Components
          - **Backend**: SMART on FHIR Proxy Server
          - **UI**: Administration Interface  
          - **Test Suite**: Comprehensive FHIR compliance tests

          ## Installation
          ```bash
          git clone https://github.com/${{ github.repository }}.git
          cd smart-on-fhir-proxy
          git checkout v${{ steps.version.outputs.new_version }}
          ```

          See the [README](README.md) for setup instructions.

          ---

          ## Auto-generated Release Notes
          EOF
              ;;
          esac

          # Create release with GitHub CLI
          if [ "${{ inputs.is_prerelease }}" = "true" ]; then
            gh release create "$tag" \
                --repo="$GITHUB_REPOSITORY" \
                --title="SMART on FHIR Proxy $tag (${{ inputs.release_type }})" \
                --notes-file release_notes.md \
                --prerelease \
                --generate-notes
          else
            gh release create "$tag" \
                --repo="$GITHUB_REPOSITORY" \
                --title="SMART on FHIR Proxy $tag" \
                --notes-file release_notes.md \
                --generate-notes
          fi
