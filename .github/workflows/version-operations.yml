name: Version Operations

on:
  workflow_call:
    inputs:
      operation:
        description: "Operation to perform: 'validate' or 'update'"
        required: true
        type: string
      release_type:
        description: "Type of release (alpha, beta, RELEASE) - only for 'update'"
        required: false
        type: string
      should_bump_version:
        description: "Whether to bump the version number - only for 'update'"
        required: false
        type: boolean
        default: false
    secrets:
      APP_ID:
        required: false
      APP_PRIVATE_KEY:
        required: false
    outputs:
      current_version:
        description: "Current version before any changes"
        value: ${{ jobs.version-ops.outputs.current_version }}
      new_version:
        description: "New version after processing (only for 'update')"
        value: ${{ jobs.version-ops.outputs.new_version }}
      base_version:
        description: "Base version without suffixes"
        value: ${{ jobs.version-ops.outputs.base_version }}
      build_number:
        description: "Build number for non-RELEASE releases"
        value: ${{ jobs.version-ops.outputs.build_number }}
      short_sha:
        description: "Short commit SHA"
        value: ${{ jobs.version-ops.outputs.short_sha }}
      is_consistent:
        description: "Whether versions are consistent across packages"
        value: ${{ jobs.version-ops.outputs.is_consistent }}

jobs:
  version-ops:
    name: Version Operations
    runs-on: ubuntu-latest
    outputs:
      current_version: ${{ steps.check.outputs.current_version }}
      new_version: ${{ steps.update.outputs.new_version }}
      base_version: ${{ steps.check.outputs.base_version }}
      build_number: ${{ steps.update.outputs.build_number }}
      short_sha: ${{ steps.update.outputs.short_sha }}
      is_consistent: ${{ steps.check.outputs.is_consistent }}
    
    steps:
      - name: Generate token (for update operations only)
        id: generate_token
        if: inputs.operation == 'update'
        uses: actions/create-github-app-token@v2
        with:
          app-id: ${{ secrets.APP_ID }}
          private-key: ${{ secrets.APP_PRIVATE_KEY }}

      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ steps.generate_token.outputs.token || github.token }}

      - name: Setup Node.js and Bun
        uses: actions/setup-node@v4
        with:
          node-version: "22"
      
      - name: Setup Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version: latest

      - name: Validate inputs
        run: |
          if [ "${{ inputs.operation }}" = "update" ]; then
            if [ -z "${{ inputs.release_type }}" ]; then
              echo "❌ release_type is required for 'update' operation"
              exit 1
            fi
          fi

      - name: Check version consistency
        id: check
        run: |
          echo "Checking version consistency across all package.json files..."
          
          # Get root version using our standard approach
          ROOT_VERSION=$(node -p "require('./package.json').version")
          echo "Root version: $ROOT_VERSION"
          echo "current_version=$ROOT_VERSION" >> $GITHUB_OUTPUT
          
          # Get base version using our script
          BASE_VERSION=$(bun run version:base)
          echo "base_version=$BASE_VERSION" >> $GITHUB_OUTPUT
          
          # Use our centralized version script to check consistency
          if bun run version:check; then
            echo "is_consistent=true" >> $GITHUB_OUTPUT
            echo "✅ All versions are consistent!"
          else
            echo "is_consistent=false" >> $GITHUB_OUTPUT
            if [ "${{ inputs.operation }}" = "validate" ]; then
              echo "❌ Version inconsistency detected!"
              echo "Run 'bun run version:sync' to fix this."
              exit 1
            else
              echo "⚠️ Version inconsistency detected, will sync automatically"
              # Auto-sync versions if in update mode
              bun run version:sync
              echo "✅ Versions synchronized automatically"
            fi
          fi

      - name: Check if version should be bumped (alpha releases only)
        id: version_check
        if: inputs.operation == 'update' && inputs.release_type == 'alpha'
        run: |
          # Get current version from current branch
          CURRENT_VERSION="${{ steps.check.outputs.current_version }}"
          CURRENT_BASE="${{ steps.check.outputs.base_version }}"

          # Get version from main branch
          git fetch origin main
          MAIN_VERSION=$(git show origin/main:package.json | node -p "JSON.parse(require('fs').readFileSync('/dev/stdin', 'utf8')).version")
          MAIN_BASE=$(echo "$MAIN_VERSION" | sed 's/-.*$//')

          echo "current_base=$CURRENT_BASE" >> $GITHUB_OUTPUT
          echo "main_base=$MAIN_BASE" >> $GITHUB_OUTPUT

          # Check if versions match (meaning we should bump)
          if [ "$CURRENT_BASE" = "$MAIN_BASE" ]; then
            echo "should_bump=true" >> $GITHUB_OUTPUT
            echo "✅ Versions match ($CURRENT_BASE = $MAIN_BASE) - will bump version"
          else
            echo "should_bump=false" >> $GITHUB_OUTPUT
            echo "⏭️  Versions differ ($CURRENT_BASE ≠ $MAIN_BASE) - will use current version"
          fi

      - name: Update versions
        id: update
        if: inputs.operation == 'update'
        run: |
          BASE_VERSION="${{ steps.check.outputs.base_version }}"
          CURRENT_VERSION="${{ steps.check.outputs.current_version }}"
          
          # Use release_type directly as version suffix
          VERSION_SUFFIX="${{ inputs.release_type }}"
          
          # Extract existing build number from current version (if any)
          EXISTING_BUILD_NUMBER=""
          if [[ "$CURRENT_VERSION" =~ -[a-zA-Z]+\.([0-9]+)\. ]]; then
            EXISTING_BUILD_NUMBER="${BASH_REMATCH[1]}"
            echo "Found existing build number: $EXISTING_BUILD_NUMBER"
          fi
          
          # Generate build info
          SHORT_SHA=$(git rev-parse --short HEAD)
          echo "short_sha=$SHORT_SHA" >> $GITHUB_OUTPUT
          
          # Build number logic:
          # - Alpha: Generate new build number
          # - Beta/RELEASE: Inherit from existing version
          case "${{ inputs.release_type }}" in
            "alpha")
              BUILD_NUMBER=$(date +%Y%m%d%H%M)
              echo "build_number=$BUILD_NUMBER" >> $GITHUB_OUTPUT
              ;;
            "beta"|"RELEASE")
              if [ -n "$EXISTING_BUILD_NUMBER" ]; then
                BUILD_NUMBER="$EXISTING_BUILD_NUMBER"
                echo "build_number=$BUILD_NUMBER" >> $GITHUB_OUTPUT
                echo "Inheriting build number: $BUILD_NUMBER"
              else
                echo "❌ No existing build number found in version: $CURRENT_VERSION"
                echo "Beta and RELEASE builds require an existing build number from alpha"
                exit 1
              fi
              ;;
          esac

          # Determine new version based on release type and bump requirements
          case "${{ inputs.release_type }}" in
            "alpha")
              if [ "${{ inputs.should_bump_version }}" = "true" ] && [ "${{ steps.version_check.outputs.should_bump }}" = "true" ]; then
                # Use our bump script to increment patch version
                bun run version:bump
                NEW_BASE=$(node -p "require('./package.json').version")
                NEW_VERSION="${NEW_BASE}-${VERSION_SUFFIX}.${BUILD_NUMBER}.${SHORT_SHA}"
              else
                NEW_VERSION="${BASE_VERSION}-${VERSION_SUFFIX}.${BUILD_NUMBER}.${SHORT_SHA}"
              fi
              ;;
            "beta")
              # For beta, keep the same base version but change suffix to beta
              # This preserves version progression: alpha -> beta -> RELEASE
              NEW_VERSION="${BASE_VERSION}-${VERSION_SUFFIX}.${BUILD_NUMBER}.${SHORT_SHA}"
              echo "Promoting from current version: $CURRENT_VERSION"
              echo "To beta version: $NEW_VERSION"
              ;;
            "RELEASE")
              NEW_VERSION="${BASE_VERSION}-${VERSION_SUFFIX}.${BUILD_NUMBER}"
              ;;
            *)
              echo "❌ Unknown release type: ${{ inputs.release_type }}"
              exit 1
              ;;
          esac

          echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "Final version: $NEW_VERSION"

          # Use our centralized version script to set the final version
          bun run version:set "$NEW_VERSION"
          
          # Verify versions are now consistent using our centralized script
          echo "Verifying version consistency:"
          bun run version:check

          # Update README version badge with simplified version
          if [ -f "README.md" ]; then
            # Simplify version for badge (strip build number and SHA)
            BADGE_VERSION="${BASE_VERSION}-${VERSION_SUFFIX}"

            # Update the version badge - handle complex version formats with build numbers and SHA
            # This regex matches: vX.X.X.anything-blue and replaces with v$BADGE_VERSION-blue
            sed -i "s/v[0-9]\+\.[0-9]\+\.[0-9]\+[^-]*\(-blue\)/v$BADGE_VERSION\1/g" README.md
            echo "Updated README.md version badge to $BADGE_VERSION"
          fi

          # Commit the version changes (only for update operations)
          if [ "${{ inputs.operation }}" = "update" ]; then
            # Configure git
            git config --global user.name 'github-actions[bot]'
            git config --global user.email 'github-actions[bot]@users.noreply.github.com'

            # Add files to commit
            FILES_TO_ADD="package.json"
            for file in backend/package.json ui/package.json testing/alpha/package.json testing/beta/package.json testing/production/package.json README.md; do
              if [ -f "$file" ]; then
                FILES_TO_ADD="$FILES_TO_ADD $file"
              fi
            done

            git add $FILES_TO_ADD
            
            # Check if there are changes to commit
            if git diff --staged --quiet; then
              echo "No version changes to commit"
            else
              case "${{ inputs.release_type }}" in
                "alpha")
                  COMMIT_MSG="🔄 Update version to $NEW_VERSION (alpha)"
                  ;;
                "beta")
                  COMMIT_MSG="🔄 Update version to $NEW_VERSION (beta)"
                  ;;
                "RELEASE")
                  COMMIT_MSG="🔄 Update version to $NEW_VERSION"
                  ;;
                *)
                  COMMIT_MSG="🔄 Update version to $NEW_VERSION"
                  ;;
              esac

              git commit -m "$COMMIT_MSG"
              git push origin HEAD
              echo "✅ Committed version changes: $NEW_VERSION"
            fi
          fi
