name: SMART Compliance Tests (Inferno)

on:
  # Manual trigger
  workflow_dispatch:
    inputs:
      test_suite:
        description: 'Test suite to run'
        required: true
        default: 'smart_stu2_2'
        type: choice
        options:
          - smart_stu2_2
          - smart_stu2
          - smart_stu1
  # Run on releases
  push:
    tags:
      - 'v*'
  # Scheduled weekly run
  schedule:
    - cron: '0 6 * * 1'  # Every Monday at 6 AM UTC

env:
  INFERNO_VERSION: main
  TEST_SUITE: ${{ inputs.test_suite || 'smart_stu2_2' }}

jobs:
  smart-compliance-test:
    name: SMART ${{ inputs.test_suite || 'STU2.2' }} Compliance
    runs-on: ubuntu-latest
    timeout-minutes: 30
    
    services:
      postgres:
        image: postgres:17-alpine
        env:
          POSTGRES_USER: keycloak
          POSTGRES_PASSWORD: keycloak
          POSTGRES_DB: keycloak
        ports:
          - 5432:5432
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
      
      # Inferno's postgres
      inferno-db:
        image: postgres:17-alpine
        env:
          POSTGRES_USER: inferno
          POSTGRES_PASSWORD: inferno
          POSTGRES_DB: inferno
        ports:
          - 5433:5432
        options: >-
          --health-cmd pg_isready
          --health-interval 5s
          --health-timeout 5s
          --health-retries 5
      
      # Redis for Inferno
      redis:
        image: redis:8-alpine
        ports:
          - 6379:6379
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 5s
          --health-timeout 5s
          --health-retries 5
      
      # HAPI FHIR Server - standard R4 test server
      # Note: HAPI takes ~35 seconds to start. We use a simple TCP check.
      hapi-fhir:
        image: hapiproject/hapi:v8.6.0-1
        ports:
          - 8081:8080
        env:
          hapi.fhir.default_encoding: json
          hapi.fhir.fhir_version: R4

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version: latest

      - name: Install dependencies
        run: bun install

      - name: Build Backend
        run: |
          cd backend
          bun run build

      # Start Keycloak with realm import
      - name: Start Keycloak
        run: |
          # Copy realm export to a temp location for mounting
          mkdir -p /tmp/keycloak-import
          cp keycloak/realm-export.json /tmp/keycloak-import/
          
          docker run -d \
            --name keycloak \
            --network host \
            -v /tmp/keycloak-import:/opt/keycloak/data/import \
            -e KEYCLOAK_ADMIN=admin \
            -e KEYCLOAK_ADMIN_PASSWORD=admin \
            -e KC_DB=postgres \
            -e KC_DB_URL=jdbc:postgresql://localhost:5432/keycloak \
            -e KC_DB_USERNAME=keycloak \
            -e KC_DB_PASSWORD=keycloak \
            -e KC_HEALTH_ENABLED=true \
            -e KC_HTTP_ENABLED=true \
            -e KC_HOSTNAME_STRICT=false \
            quay.io/keycloak/keycloak:26.0.5 \
            start-dev --import-realm
          
          # Wait for Keycloak to be ready
          echo "Waiting for Keycloak..."
          for i in {1..90}; do
            if curl -sf http://localhost:8080/health/ready; then
              echo "Keycloak is ready!"
              break
            fi
            echo "Attempt $i/90..."
            sleep 5
          done
          
          # Verify realm was imported
          sleep 5
          echo "Checking realm..."
          TOKEN=$(curl -s -X POST "http://localhost:8080/realms/master/protocol/openid-connect/token" \
            -H "Content-Type: application/x-www-form-urlencoded" \
            -d "grant_type=password&client_id=admin-cli&username=admin&password=admin" | jq -r '.access_token')
          
          REALMS=$(curl -s "http://localhost:8080/admin/realms" -H "Authorization: Bearer $TOKEN" | jq -r '.[].realm')
          echo "Available realms: $REALMS"
          
          if echo "$REALMS" | grep -q "proxy-smart"; then
            echo "proxy-smart realm found!"
          else
            echo "proxy-smart realm not found, creating it..."
            curl -s -X POST "http://localhost:8080/admin/realms" \
              -H "Authorization: Bearer $TOKEN" \
              -H "Content-Type: application/json" \
              -d '{"realm": "proxy-smart", "enabled": true}'
          fi

      # Wait for HAPI FHIR to be ready (takes ~35 seconds to start)
      - name: Wait for HAPI FHIR
        run: |
          echo "Waiting for HAPI FHIR server to be ready..."
          for i in {1..60}; do
            if curl -sf http://localhost:8081/fhir/metadata > /dev/null 2>&1; then
              echo "✓ HAPI FHIR is ready!"
              curl -s http://localhost:8081/fhir/metadata | jq -r '.fhirVersion' | xargs -I{} echo "  FHIR Version: {}"
              exit 0
            fi
            echo "Attempt $i/60 - waiting for HAPI FHIR..."
            sleep 2
          done
          echo "ERROR: HAPI FHIR failed to start in time"
          exit 1

      # Start the application
      - name: Start Application
        run: |
          cd backend
          bun run start &
          APP_PID=$!
          echo "app_pid=$APP_PID" >> $GITHUB_ENV
          
          # Wait for app to be ready
          echo "Waiting for application..."
          for i in {1..30}; do
            if curl -sf http://localhost:8445/health; then
              echo "Application is ready!"
              break
            fi
            echo "Attempt $i/30..."
            sleep 2
          done
        env:
          NODE_ENV: production
          KEYCLOAK_BASE_URL: http://localhost:8080
          KEYCLOAK_REALM: proxy-smart
          # Point to HAPI FHIR server running in GitHub Actions service container
          FHIR_SERVER_BASE: http://localhost:8081/fhir

      # Setup Node.js for Playwright
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install Playwright
        run: |
          # Install Playwright in a separate directory to avoid workspace package.json issues
          mkdir -p /tmp/playwright-setup
          cd /tmp/playwright-setup
          npm init -y
          npm install playwright
          npx playwright install chromium --with-deps
          # Copy playwright to workspace node_modules for script access
          mkdir -p $GITHUB_WORKSPACE/node_modules
          cp -r node_modules/playwright* $GITHUB_WORKSPACE/node_modules/ || true

      - name: Setup Ruby
        uses: ruby/setup-ruby@v1
        with:
          ruby-version: '3.3'
          bundler-cache: false

      - name: Setup Inferno
        run: |
          git clone https://github.com/inferno-framework/smart-app-launch-test-kit.git inferno
          cd inferno
          bundle install
          
          # Setup database
          export DATABASE_URL="postgresql://inferno:inferno@localhost:5433/inferno"
          export REDIS_URL="redis://localhost:6379"
          bundle exec rake db:migrate || bundle exec rake db:setup || true

      - name: Start Inferno
        run: |
          cd inferno
          export DATABASE_URL="postgresql://inferno:inferno@localhost:5433/inferno"
          export REDIS_URL="redis://localhost:6379"
          
          # Start Sidekiq worker for background job processing (test runs)
          bundle exec sidekiq &
          SIDEKIQ_PID=$!
          echo "Started Sidekiq worker (PID: $SIDEKIQ_PID)"
          
          # Start Inferno web server in background
          bundle exec puma -p 4567 &
          PUMA_PID=$!
          echo "Started Puma server (PID: $PUMA_PID)"
          
          # Wait for Inferno to be ready
          echo "Waiting for Inferno..."
          for i in {1..60}; do
            if curl -sf http://localhost:4567 > /dev/null 2>&1; then
              echo "Inferno is ready!"
              break
            fi
            echo "Attempt $i/60..."
            sleep 5
          done

      # Register test client in Keycloak
      - name: Register Inferno Client
        run: |
          # Get admin token
          TOKEN=$(curl -s -X POST "http://localhost:8080/realms/master/protocol/openid-connect/token" \
            -H "Content-Type: application/x-www-form-urlencoded" \
            -d "grant_type=password" \
            -d "client_id=admin-cli" \
            -d "username=admin" \
            -d "password=admin" | jq -r '.access_token')
          
          echo "Admin token obtained: ${TOKEN:0:20}..."
          
          # Check if realm exists
          REALM_CHECK=$(curl -s -o /dev/null -w "%{http_code}" \
            "http://localhost:8080/admin/realms/proxy-smart" \
            -H "Authorization: Bearer $TOKEN")
          
          if [ "$REALM_CHECK" != "200" ]; then
            echo "Creating proxy-smart realm..."
            curl -s -X POST "http://localhost:8080/admin/realms" \
              -H "Authorization: Bearer $TOKEN" \
              -H "Content-Type: application/json" \
              -d '{"realm": "proxy-smart", "enabled": true}'
          fi
          
          # Create client
          echo "Creating Inferno client..."
          RESULT=$(curl -s -w "\n%{http_code}" -X POST "http://localhost:8080/admin/realms/proxy-smart/clients" \
            -H "Authorization: Bearer $TOKEN" \
            -H "Content-Type: application/json" \
            -d '{
              "clientId": "inferno-test-client",
              "enabled": true,
              "publicClient": true,
              "standardFlowEnabled": true,
              "directAccessGrantsEnabled": true,
              "redirectUris": [
                "http://localhost:4567/custom/smart_stu2_2/redirect",
                "http://localhost:4567/custom/smart_stu2/redirect",
                "http://localhost:4567/*"
              ],
              "webOrigins": ["http://localhost:4567"],
              "attributes": {
                "pkce.code.challenge.method": "S256"
              }
            }')
          
          HTTP_CODE=$(echo "$RESULT" | tail -1)
          BODY=$(echo "$RESULT" | head -n -1)
          
          if [ "$HTTP_CODE" = "201" ] || [ "$HTTP_CODE" = "409" ]; then
            echo "Client registered (or already exists)"
          else
            echo "Client registration response: $HTTP_CODE"
            echo "$BODY"
          fi

      # Run Inferno tests via Playwright automation
      - name: Run SMART Compliance Tests
        id: inferno-tests
        continue-on-error: true
        run: |
          set +e  # Disable exit on error for robust handling
          
          echo "=== SMART 2.2.0 Compliance Testing with Inferno ==="
          echo ""
          
          # Get FHIR server URL from our proxy
          echo "### Step 0: Discovering FHIR Servers ###"
          SERVERS=$(curl -s "http://localhost:8445/fhir-servers" 2>&1)
          echo "Available FHIR servers:"
          echo "$SERVERS" | jq '.' 2>/dev/null || echo "$SERVERS"
          
          # Get the first server's endpoints
          SMART_CONFIG_URL=$(echo "$SERVERS" | jq -r '.servers[0].endpoints.smartConfig // empty' 2>/dev/null)
          BASE_FHIR_URL=$(echo "$SERVERS" | jq -r '.servers[0].endpoints.base // empty' 2>/dev/null)
          
          if [ -z "$SMART_CONFIG_URL" ] || [ "$SMART_CONFIG_URL" = "null" ]; then
            echo "::warning::No FHIR servers configured - cannot test SMART configuration"
            echo "## SMART Compliance Tests - SKIPPED" >> $GITHUB_STEP_SUMMARY
            echo "No FHIR servers configured." >> $GITHUB_STEP_SUMMARY
            echo "passed=0" >> $GITHUB_OUTPUT
            echo "failed=0" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          echo ""
          echo "Using SMART config URL: $SMART_CONFIG_URL"
          echo "Using FHIR base URL: $BASE_FHIR_URL"
          
          # Step 1: Quick validation of SMART configuration
          echo ""
          echo "### Step 1: Quick SMART Configuration Validation ###"
          SMART_CONFIG=$(curl -s "$SMART_CONFIG_URL" 2>&1)
          echo "$SMART_CONFIG" | jq '.'
          
          # Check required fields
          AUTH_EP=$(echo "$SMART_CONFIG" | jq -r '.authorization_endpoint // empty')
          TOKEN_EP=$(echo "$SMART_CONFIG" | jq -r '.token_endpoint // empty')
          
          if [ -z "$AUTH_EP" ] || [ -z "$TOKEN_EP" ]; then
            echo "::error::Missing required SMART endpoints"
            echo "## SMART Compliance Tests - FAILED" >> $GITHUB_STEP_SUMMARY
            echo "Missing authorization_endpoint or token_endpoint" >> $GITHUB_STEP_SUMMARY
            echo "passed=0" >> $GITHUB_OUTPUT
            echo "failed=1" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          echo "✓ authorization_endpoint: $AUTH_EP"
          echo "✓ token_endpoint: $TOKEN_EP"
          
          # Step 2: Run Inferno tests with Playwright OAuth automation
          echo ""
          echo "### Step 2: Running Inferno Tests with Playwright ###"
          
          # Copy the script to the Playwright directory and run it from there
          cp .github/scripts/inferno-oauth-automation.js /tmp/playwright-setup/
          cd /tmp/playwright-setup
          node inferno-oauth-automation.js 2>&1 | tee $GITHUB_WORKSPACE/inferno-output.log
          INFERNO_EXIT_CODE=${PIPESTATUS[0]}
          cd $GITHUB_WORKSPACE
          
          # Parse results from the log
          if grep -q "PASS:" inferno-output.log; then
            PASSED=$(grep -c "✓ PASS:" inferno-output.log || echo "0")
            FAILED=$(grep -c "✗ FAIL:" inferno-output.log || echo "0")
          else
            PASSED=0
            FAILED=0
          fi
          
          # Write summary
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## SMART 2.2.0 Compliance Test Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [ "$INFERNO_EXIT_CODE" -eq 0 ]; then
            echo "**Status: ✓ PASSED**" >> $GITHUB_STEP_SUMMARY
          else
            echo "**Status: ✗ FAILED**" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Test Summary" >> $GITHUB_STEP_SUMMARY
          echo "- Passed: $PASSED" >> $GITHUB_STEP_SUMMARY
          echo "- Failed: $FAILED" >> $GITHUB_STEP_SUMMARY
          
          # Include FHIR server info
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### FHIR Server Configuration" >> $GITHUB_STEP_SUMMARY
          FHIR_VERSION=$(echo "$SMART_CONFIG" | jq -r '.fhirVersion // "R4"')
          echo "- FHIR Version: $FHIR_VERSION" >> $GITHUB_STEP_SUMMARY
          echo "- Authorization Endpoint: $AUTH_EP" >> $GITHUB_STEP_SUMMARY
          echo "- Token Endpoint: $TOKEN_EP" >> $GITHUB_STEP_SUMMARY
          
          # Set outputs
          echo "passed=$PASSED" >> $GITHUB_OUTPUT
          echo "failed=$FAILED" >> $GITHUB_OUTPUT
          
          exit $INFERNO_EXIT_CODE
        env:
          INFERNO_URL: http://localhost:4567
          FHIR_SERVER_URL: http://localhost:8445/proxy-smart-backend/hapi-fhir-server/R4
          TEST_SUITE: ${{ env.TEST_SUITE }}
          CLIENT_ID: inferno-test-client
          KC_USERNAME: doctor
          KC_PASSWORD: doctor123

      # Save test results
      - name: Save Test Results
        if: always()
        run: |
          mkdir -p test-results
          
          # Discover servers and get SMART config URL
          SERVERS=$(curl -s "http://localhost:8445/fhir-servers" 2>&1)
          SMART_CONFIG_URL=$(echo "$SERVERS" | jq -r '.servers[0].endpoints.smartConfig // empty' 2>/dev/null)
          METADATA_URL=$(echo "$SERVERS" | jq -r '.servers[0].endpoints.metadata // empty' 2>/dev/null)
          
          # Save server discovery info
          echo "$SERVERS" > test-results/fhir-servers.json
          
          # Save SMART configuration if URL available
          if [ -n "$SMART_CONFIG_URL" ] && [ "$SMART_CONFIG_URL" != "null" ]; then
            curl -s "$SMART_CONFIG_URL" > test-results/smart-configuration.json 2>/dev/null || echo "{}" > test-results/smart-configuration.json
          else
            echo "{\"note\": \"No FHIR servers configured\"}" > test-results/smart-configuration.json
          fi
          
          # Save FHIR metadata if URL available
          if [ -n "$METADATA_URL" ] && [ "$METADATA_URL" != "null" ]; then
            curl -s "$METADATA_URL" > test-results/fhir-metadata.json 2>/dev/null || echo "{}" > test-results/fhir-metadata.json
          else
            echo "{\"note\": \"No FHIR servers configured\"}" > test-results/fhir-metadata.json
          fi
          
          # Save Inferno test output
          cp inferno-output.log test-results/inferno-output.log 2>/dev/null || true
          
          # Save Playwright screenshots if any
          cp oauth-error.png test-results/oauth-error.png 2>/dev/null || true
          
          # Also save service logs
          docker logs keycloak > test-results/keycloak.log 2>&1 || true

      - name: Upload Artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: inferno-test-results
          path: test-results/
          retention-days: 30

      # Cleanup
      - name: Cleanup
        if: always()
        run: |
          docker stop keycloak || true
          docker rm keycloak || true
          pkill -f "bun run start" || true
          pkill -f puma || true
