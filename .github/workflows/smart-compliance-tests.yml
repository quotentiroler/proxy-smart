name: SMART Compliance Tests (Inferno)

on:
  # Manual trigger
  workflow_dispatch:
    inputs:
      test_suite:
        description: 'Test suite to run'
        required: true
        default: 'smart_stu2_2'
        type: choice
        options:
          - smart_stu2_2
          - smart_stu2
          - smart_stu1
  # Run on releases
  push:
    tags:
      - 'v*'
  # Scheduled weekly run
  schedule:
    - cron: '0 6 * * 1'  # Every Monday at 6 AM UTC

env:
  INFERNO_VERSION: main
  TEST_SUITE: ${{ inputs.test_suite || 'smart_stu2_2' }}

jobs:
  smart-compliance-test:
    name: SMART ${{ inputs.test_suite || 'STU2.2' }} Compliance
    runs-on: ubuntu-latest
    timeout-minutes: 30
    
    services:
      postgres:
        image: postgres:16-alpine
        env:
          POSTGRES_USER: keycloak
          POSTGRES_PASSWORD: keycloak
          POSTGRES_DB: keycloak
        ports:
          - 5432:5432
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
      
      # Inferno's postgres
      inferno-db:
        image: postgres:16-alpine
        env:
          POSTGRES_USER: inferno
          POSTGRES_PASSWORD: inferno
          POSTGRES_DB: inferno
        ports:
          - 5433:5432
        options: >-
          --health-cmd pg_isready
          --health-interval 5s
          --health-timeout 5s
          --health-retries 5
      
      # Redis for Inferno
      redis:
        image: redis:7-alpine
        ports:
          - 6379:6379
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 5s
          --health-timeout 5s
          --health-retries 5

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Bun
        uses: ./.github/actions/setup-bun-version
        with:
          bun-version: '1.3.5'

      - name: Install dependencies
        run: |
          rm -rf ~/.bun/install/cache || true
          bun install

      - name: Build Backend
        run: |
          cd backend
          bun run build

      # Start Keycloak with realm import
      - name: Start Keycloak
        run: |
          # Copy realm export to a temp location for mounting
          mkdir -p /tmp/keycloak-import
          cp keycloak/realm-export.json /tmp/keycloak-import/
          
          docker run -d \
            --name keycloak \
            --network host \
            -v /tmp/keycloak-import:/opt/keycloak/data/import \
            -e KEYCLOAK_ADMIN=admin \
            -e KEYCLOAK_ADMIN_PASSWORD=admin \
            -e KC_DB=postgres \
            -e KC_DB_URL=jdbc:postgresql://localhost:5432/keycloak \
            -e KC_DB_USERNAME=keycloak \
            -e KC_DB_PASSWORD=keycloak \
            -e KC_HEALTH_ENABLED=true \
            -e KC_HTTP_ENABLED=true \
            -e KC_HOSTNAME_STRICT=false \
            quay.io/keycloak/keycloak:26.0.5 \
            start-dev --import-realm
          
          # Wait for Keycloak to be ready
          echo "Waiting for Keycloak..."
          for i in {1..90}; do
            if curl -sf http://localhost:8080/health/ready; then
              echo "Keycloak is ready!"
              break
            fi
            echo "Attempt $i/90..."
            sleep 5
          done
          
          # Verify realm was imported
          sleep 5
          echo "Checking realm..."
          TOKEN=$(curl -s -X POST "http://localhost:8080/realms/master/protocol/openid-connect/token" \
            -H "Content-Type: application/x-www-form-urlencoded" \
            -d "grant_type=password&client_id=admin-cli&username=admin&password=admin" | jq -r '.access_token')
          
          REALMS=$(curl -s "http://localhost:8080/admin/realms" -H "Authorization: Bearer $TOKEN" | jq -r '.[].realm')
          echo "Available realms: $REALMS"
          
          if echo "$REALMS" | grep -q "proxy-smart"; then
            echo "proxy-smart realm found!"
          else
            echo "proxy-smart realm not found, creating it..."
            curl -s -X POST "http://localhost:8080/admin/realms" \
              -H "Authorization: Bearer $TOKEN" \
              -H "Content-Type: application/json" \
              -d '{"realm": "proxy-smart", "enabled": true}'
          fi

      # Start the application
      - name: Start Application
        run: |
          cd backend
          bun run start &
          APP_PID=$!
          echo "app_pid=$APP_PID" >> $GITHUB_ENV
          
          # Wait for app to be ready
          echo "Waiting for application..."
          for i in {1..30}; do
            if curl -sf http://localhost:8445/health; then
              echo "Application is ready!"
              break
            fi
            echo "Attempt $i/30..."
            sleep 2
          done
        env:
          NODE_ENV: production
          KEYCLOAK_URL: http://localhost:8080

      # Setup Ruby and Inferno
      - name: Setup Ruby
        uses: ruby/setup-ruby@v1
        with:
          ruby-version: '3.2'
          bundler-cache: false

      - name: Setup Inferno
        run: |
          git clone https://github.com/inferno-framework/smart-app-launch-test-kit.git inferno
          cd inferno
          bundle install
          
          # Setup database
          export DATABASE_URL="postgresql://inferno:inferno@localhost:5433/inferno"
          export REDIS_URL="redis://localhost:6379"
          bundle exec rake db:migrate || bundle exec rake db:setup || true

      - name: Start Inferno
        run: |
          cd inferno
          export DATABASE_URL="postgresql://inferno:inferno@localhost:5433/inferno"
          export REDIS_URL="redis://localhost:6379"
          
          # Start Inferno in background
          bundle exec puma -p 4567 &
          
          # Wait for Inferno to be ready
          echo "Waiting for Inferno..."
          for i in {1..60}; do
            if curl -sf http://localhost:4567 > /dev/null 2>&1; then
              echo "Inferno is ready!"
              break
            fi
            echo "Attempt $i/60..."
            sleep 5
          done

      # Register test client in Keycloak
      - name: Register Inferno Client
        run: |
          # Get admin token
          TOKEN=$(curl -s -X POST "http://localhost:8080/realms/master/protocol/openid-connect/token" \
            -H "Content-Type: application/x-www-form-urlencoded" \
            -d "grant_type=password" \
            -d "client_id=admin-cli" \
            -d "username=admin" \
            -d "password=admin" | jq -r '.access_token')
          
          echo "Admin token obtained: ${TOKEN:0:20}..."
          
          # Check if realm exists
          REALM_CHECK=$(curl -s -o /dev/null -w "%{http_code}" \
            "http://localhost:8080/admin/realms/proxy-smart" \
            -H "Authorization: Bearer $TOKEN")
          
          if [ "$REALM_CHECK" != "200" ]; then
            echo "Creating proxy-smart realm..."
            curl -s -X POST "http://localhost:8080/admin/realms" \
              -H "Authorization: Bearer $TOKEN" \
              -H "Content-Type: application/json" \
              -d '{"realm": "proxy-smart", "enabled": true}'
          fi
          
          # Create client
          echo "Creating Inferno client..."
          RESULT=$(curl -s -w "\n%{http_code}" -X POST "http://localhost:8080/admin/realms/proxy-smart/clients" \
            -H "Authorization: Bearer $TOKEN" \
            -H "Content-Type: application/json" \
            -d '{
              "clientId": "inferno-test-client",
              "enabled": true,
              "publicClient": true,
              "standardFlowEnabled": true,
              "directAccessGrantsEnabled": true,
              "redirectUris": [
                "http://localhost:4567/custom/smart_stu2_2/redirect",
                "http://localhost:4567/custom/smart_stu2/redirect",
                "http://localhost:4567/*"
              ],
              "webOrigins": ["http://localhost:4567"],
              "attributes": {
                "pkce.code.challenge.method": "S256"
              }
            }')
          
          HTTP_CODE=$(echo "$RESULT" | tail -1)
          BODY=$(echo "$RESULT" | head -n -1)
          
          if [ "$HTTP_CODE" = "201" ] || [ "$HTTP_CODE" = "409" ]; then
            echo "Client registered (or already exists)"
          else
            echo "Client registration response: $HTTP_CODE"
            echo "$BODY"
          fi

      # Run Inferno tests via API
      - name: Run SMART Compliance Tests
        id: inferno-tests
        continue-on-error: true
        run: |
          echo "=== Checking Inferno API ==="
          
          # List available test suites
          SUITES=$(curl -s "http://localhost:4567/api/test_suites" || echo "[]")
          echo "Available suites: $SUITES"
          
          # Create test session
          echo "Creating test session for $TEST_SUITE..."
          SESSION_RESPONSE=$(curl -s -X POST "http://localhost:4567/api/test_sessions" \
            -H "Content-Type: application/json" \
            -d "{\"test_suite_id\": \"$TEST_SUITE\"}" || echo "{}")
          
          echo "Session response: $SESSION_RESPONSE"
          SESSION=$(echo "$SESSION_RESPONSE" | jq -r '.id // empty')
          
          if [ -z "$SESSION" ]; then
            echo "::warning::Could not create test session. Inferno API may not be ready."
            echo "## SMART Compliance Tests" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "Could not run automated tests - Inferno API not responding as expected." >> $GITHUB_STEP_SUMMARY
            exit 0
          fi
          
          echo "Created test session: $SESSION"
          echo "session_id=$SESSION" >> $GITHUB_OUTPUT
          
          # Get test suite info
          SUITE_INFO=$(curl -s "http://localhost:4567/api/test_suites/$TEST_SUITE")
          FIRST_GROUP=$(echo "$SUITE_INFO" | jq -r '.test_groups[0].id // empty')
          
          if [ -z "$FIRST_GROUP" ]; then
            echo "::warning::Could not find test groups"
            exit 0
          fi
          
          echo "Running test group: $FIRST_GROUP"
          
          # Run tests with inputs
          RUN_RESPONSE=$(curl -s -X POST "http://localhost:4567/api/test_runs" \
            -H "Content-Type: application/json" \
            -d "{
              \"test_session_id\": \"$SESSION\",
              \"test_group_id\": \"$FIRST_GROUP\",
              \"inputs\": [
                {\"name\": \"url\", \"value\": \"http://localhost:8445/fhir\"},
                {\"name\": \"smart_authorization_url\", \"value\": \"http://localhost:8080/realms/proxy-smart/protocol/openid-connect/auth\"},
                {\"name\": \"smart_token_url\", \"value\": \"http://localhost:8080/realms/proxy-smart/protocol/openid-connect/token\"},
                {\"name\": \"client_id\", \"value\": \"inferno-test-client\"}
              ]
            }")
          
          echo "Run response: $RUN_RESPONSE"
          RUN=$(echo "$RUN_RESPONSE" | jq -r '.id // empty')
          
          if [ -z "$RUN" ]; then
            echo "::warning::Could not start test run"
            exit 0
          fi
          
          echo "Started test run: $RUN"
          echo "run_id=$RUN" >> $GITHUB_OUTPUT
          
          # Poll for completion (max 10 minutes)
          for i in {1..120}; do
            STATUS=$(curl -s "http://localhost:4567/api/test_runs/$RUN" | jq -r '.status // "unknown"')
            echo "Test status: $STATUS"
            
            if [ "$STATUS" = "done" ]; then
              break
            fi
            
            sleep 5
          done
          
          # Get results
          RESULTS=$(curl -s "http://localhost:4567/api/test_runs/$RUN/results")
          
          PASSED=$(echo "$RESULTS" | jq '[.[] | select(.result == "pass")] | length')
          FAILED=$(echo "$RESULTS" | jq '[.[] | select(.result == "fail")] | length')
          SKIPPED=$(echo "$RESULTS" | jq '[.[] | select(.result == "skip")] | length')
          ERRORS=$(echo "$RESULTS" | jq '[.[] | select(.result == "error")] | length')
          
          echo "## SMART Compliance Test Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Test Suite:** $TEST_SUITE" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Status | Count |" >> $GITHUB_STEP_SUMMARY
          echo "|--------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Passed | $PASSED |" >> $GITHUB_STEP_SUMMARY
          echo "| Failed | $FAILED |" >> $GITHUB_STEP_SUMMARY
          echo "| Skipped | $SKIPPED |" >> $GITHUB_STEP_SUMMARY
          echo "| Errors | $ERRORS |" >> $GITHUB_STEP_SUMMARY
          
          echo "passed=$PASSED" >> $GITHUB_OUTPUT
          echo "failed=$FAILED" >> $GITHUB_OUTPUT
          echo "skipped=$SKIPPED" >> $GITHUB_OUTPUT
          echo "errors=$ERRORS" >> $GITHUB_OUTPUT
          
          # List failed tests if any
          if [ "$FAILED" -gt 0 ] || [ "$ERRORS" -gt 0 ]; then
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### Failed/Error Tests" >> $GITHUB_STEP_SUMMARY
            echo "$RESULTS" | jq -r '.[] | select(.result == "fail" or .result == "error") | "- \(.test_id): \(.result)"' >> $GITHUB_STEP_SUMMARY
          fi

      # Save test results
      - name: Save Test Results
        if: always()
        run: |
          mkdir -p test-results
          
          RUN="${{ steps.inferno-tests.outputs.run_id }}"
          
          if [ -n "$RUN" ]; then
            curl -s "http://localhost:4567/api/test_runs/$RUN/results" > test-results/inferno-results.json 2>/dev/null || echo "[]" > test-results/inferno-results.json
          else
            echo "[]" > test-results/inferno-results.json
          fi
          
          # Also save service logs
          docker logs keycloak > test-results/keycloak.log 2>&1 || true

      - name: Upload Artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: inferno-test-results
          path: test-results/
          retention-days: 30

      # Cleanup
      - name: Cleanup
        if: always()
        run: |
          docker stop keycloak || true
          docker rm keycloak || true
          pkill -f "bun run start" || true
          pkill -f puma || true
