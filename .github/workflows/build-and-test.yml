name: Build

on:
  workflow_call:
    inputs:
      run_tests:
        description: "Whether to run tests"
        required: false
        type: boolean
        default: true
      fail_on_test_failure:
        description: "Whether to fail the workflow if tests fail"
        required: false
        type: boolean
        default: false
    secrets:
      APP_ID:
        required: false
      APP_PRIVATE_KEY:
        required: false
      OPENAI_API_KEY:
        required: false

jobs:
  build:
    name: Build Project
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Bun with version scripts
        uses: ./.github/actions/setup-bun-version
        with:
          checkout: 'false'  # Skip checkout since we already did it

      - name: Combined Build & Log
        id: build
        run: |
          set -o pipefail
          (
            echo "=== Building backend ==="
            cd backend && bun install && bun run build && cd ..
            echo "=== Building UI ==="
            cd ui && bun install && bun run build && cd ..
          ) 2>&1 | tee build.log

      - name: Authenticate as GitHub App
        if: failure()
        id: app-auth
        uses: actions/create-github-app-token@v2
        with:
          app-id: ${{ secrets.APP_ID }}
          private-key: ${{ secrets.APP_PRIVATE_KEY }}
          owner: ${{ github.repository_owner }}
          repositories: ${{ github.event.repository.name }}

      - name: Auto-fix and retry build (up to 3 attempts)
        if: failure() && steps.app-auth.outputs.token
        id: auto-fix-retry
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          GITHUB_TOKEN: ${{ steps.app-auth.outputs.token }}
        run: |
          # Install curl for API calls
          curl --version || (apt-get update && apt-get install -y curl)
          
          MAX_RETRIES=3
          RETRY_COUNT=0
          BUILD_SUCCESS=false
          
          while [ $RETRY_COUNT -lt $MAX_RETRIES ] && [ "$BUILD_SUCCESS" = "false" ]; do
            RETRY_COUNT=$((RETRY_COUNT + 1))
            echo "üîÑ Auto-fix attempt $RETRY_COUNT of $MAX_RETRIES"
            
            # Get the latest build log (either from initial build or previous retry)
            if [ $RETRY_COUNT -eq 1 ]; then
              LOG_FILE="build.log"
            else
              LOG_FILE="retry-build-$((RETRY_COUNT - 1)).log"
            fi
            
            # Ask GPT-4o for a unified diff patch via API
            echo "üìù Analyzing build errors with AI..."
            BUILD_ERRORS=$(sed -n '1,2000p' "$LOG_FILE" | sed 's/"/\\"/g' | tr '\n' ' ')
            
            curl -s -X POST "https://api.openai.com/v1/chat/completions" \
              -H "Content-Type: application/json" \
              -H "Authorization: Bearer $OPENAI_API_KEY" \
              -d "{
                \"model\": \"gpt-4o\",
                \"messages\": [
                  {
                    \"role\": \"system\",
                    \"content\": \"You are a code fixing assistant. Analyze build errors and respond with ONLY a valid unified diff patch in proper format. IMPORTANT: 1) Use correct file paths like 'ui/src/...' or 'backend/src/...', 2) Generate a proper unified diff with @@ lines, 3) No explanations or markdown code blocks, just the raw patch.\"
                  },
                  {
                    \"role\": \"user\",
                    \"content\": \"Project structure: backend/ (Node.js/Elysia/TypeScript) and ui/ (React/TypeScript). Fix this TypeScript error - the object has 'lastBackup' but type expects 'lastBsackup' (typo). Build errors (attempt $RETRY_COUNT/$MAX_RETRIES):\\n\\n$BUILD_ERRORS\"
                  }
                ],
                \"temperature\": 0.1,
                \"max_tokens\": 2000
              }" | jq -r '.choices[0].message.content' > fix-$RETRY_COUNT.patch

            # Clean up the patch - remove markdown code blocks if present
            sed -i '/^```/d' fix-$RETRY_COUNT.patch 2>/dev/null || true
            
            # Apply the patch with intelligent fallback
            PATCH_SUCCESS=false
            if [ -s fix-$RETRY_COUNT.patch ] && patch -p1 < fix-$RETRY_COUNT.patch; then
              PATCH_SUCCESS=true
              echo "‚úÖ Patch applied successfully"
            else
              echo "‚ùå Patch failed to apply, trying intelligent error parsing..."
              
              # Generic error parsing for any build system
              while IFS= read -r error_line; do
                echo "üîç Analyzing error: $error_line"
                
                # Generic pattern: extract file paths from error messages
                if [[ "$error_line" =~ ([a-zA-Z0-9_./\\-]+\.(ts|tsx|js|jsx|py|java|cpp|c|h|go|rs|php|rb|cs|kt|swift|scala|dart))[[:space:]]*[\(:]?[[:space:]]*([0-9]+)? ]]; then
                  file_path="${BASH_REMATCH[1]}"
                  line_num="${BASH_REMATCH[3]}"
                  
                  echo "üìÅ Found file reference: $file_path"
                  
                  # Generic property/variable name mismatches
                  if [[ "$error_line" =~ \'([^\']+)\'.*does\ not\ exist && "$error_line" =~ \'([^\']+)\' ]]; then
                    # Extract all quoted strings from error message
                    quoted_strings=($(echo "$error_line" | grep -oP "'[^']+'" | tr -d "'"))
                    if [ ${#quoted_strings[@]} -ge 2 ]; then
                      wrong_name="${quoted_strings[0]}"
                      possible_correct="${quoted_strings[1]}"
                      
                      echo "ÔøΩ Property/variable mismatch detected: '$wrong_name' -> '$possible_correct'"
                      
                      if [ -f "$file_path" ] && [ -n "$wrong_name" ] && [ -n "$possible_correct" ]; then
                        # Try various common patterns
                        for pattern in "${wrong_name}:" "${wrong_name} =" "= ${wrong_name}" "var ${wrong_name}" "let ${wrong_name}" "const ${wrong_name}" "${wrong_name}(" ".${wrong_name}"; do
                          replacement="${pattern/${wrong_name}/${possible_correct}}"
                          if grep -q "$pattern" "$file_path" 2>/dev/null; then
                            echo "ÔøΩ Replacing pattern '$pattern' with '$replacement'"
                            if sed -i "s/${pattern}/${replacement}/g" "$file_path" 2>/dev/null; then
                              PATCH_SUCCESS=true
                              echo "‚úÖ Applied generic name fix"
                              break
                            fi
                          fi
                        done
                      fi
                    fi
                  fi
                  
                  # Generic "undefined" or "not found" errors
                  if [[ "$error_line" =~ (undefined|not\ found|cannot\ find|unresolved).*\'([^\']+)\' ]]; then
                    missing_item="${BASH_REMATCH[2]}"
                    echo "üîç Missing item detected: '$missing_item'"
                    
                    # Common fix patterns for missing imports/references
                    if [ -f "$file_path" ]; then
                      # Check if it might be a typo by looking for similar names in the file
                      similar_names=$(grep -oP '\b\w*'"${missing_item:0:3}"'\w*\b' "$file_path" 2>/dev/null | sort -u | head -5)
                      echo "üîç Similar names found: $similar_names"
                    fi
                  fi
                fi
              done < <(grep -E "(error|Error|ERROR|warning|Warning|WARN)" "$LOG_FILE")
              
              if [ "$PATCH_SUCCESS" = "false" ]; then
                echo "‚ö†Ô∏è Could not automatically fix errors with generic parsing"
              fi
            fi

            # Only commit & push if patch was applied successfully AND there are actual code changes
            if [ "$PATCH_SUCCESS" = "true" ]; then
              # Remove build artifacts and patch files from staging
              git reset build.log fix-*.patch retry-build-*.log codex-prompt.txt 2>/dev/null || true
              rm -f build.log fix-*.patch retry-build-*.log codex-prompt.txt 2>/dev/null || true
              
              git config user.name "github-actions[bot]"
              git config user.email "github-actions[bot]@users.noreply.github.com"
              
              # Check if there are actual code changes (excluding build artifacts)
              if [ -n "$(git status --porcelain | grep -v build.log | grep -v fix-.*\.patch | grep -v retry-build-.*\.log | grep -v codex-prompt.txt)" ]; then
                git add .
                git commit -m "chore: auto-fix build errors (attempt $RETRY_COUNT/$MAX_RETRIES) via OpenAI [skip ci]"
                git push
                echo "‚úÖ Code fixes applied and pushed (attempt $RETRY_COUNT)"
              else
                echo "‚ö†Ô∏è No actual code changes to commit"
              fi
            else
              echo "‚ö†Ô∏è Skipping commit - patch failed to apply"
            fi
            
            # Retry the build
            echo "ÔøΩ Retrying build (attempt $RETRY_COUNT)..."
            set +e  # Don't exit on error
            (
              echo "=== Retrying Backend Build (attempt $RETRY_COUNT) ==="
              cd backend && bun install && bun run build && cd ..
              echo "=== Retrying UI Build (attempt $RETRY_COUNT) ==="
              cd ui && bun install && bun run build && cd ..
            ) 2>&1 | tee retry-build-$RETRY_COUNT.log
            
            BUILD_EXIT_CODE=$?
            set -e  # Re-enable exit on error
            
            if [ $BUILD_EXIT_CODE -eq 0 ]; then
              BUILD_SUCCESS=true
              echo "‚úÖ Build succeeded on attempt $RETRY_COUNT!"
              echo "build_success=true" >> $GITHUB_OUTPUT
              echo "attempts_used=$RETRY_COUNT" >> $GITHUB_OUTPUT
              break
            else
              echo "‚ùå Build failed on attempt $RETRY_COUNT"
              if [ $RETRY_COUNT -eq $MAX_RETRIES ]; then
                echo "üí• All $MAX_RETRIES attempts failed. Giving up."
                echo "build_success=false" >> $GITHUB_OUTPUT
                echo "attempts_used=$RETRY_COUNT" >> $GITHUB_OUTPUT
                exit 1
              fi
            fi
          done

      - name: Upload build artifacts
        if: (success() || steps.auto-fix-retry.outputs.build_success == 'true') && !startsWith(github.ref, 'refs/heads/dev/')
        uses: actions/upload-artifact@v4
        with:
          name: build-artifacts
          path: |
            backend/dist/
            ui/dist/
          retention-days: 1

  test:
    name: Run Tests
    runs-on: ubuntu-latest
    needs: build
    if: ${{ inputs.run_tests }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Bun with version scripts
        uses: ./.github/actions/setup-bun-version
        with:
          checkout: 'false'  # Skip checkout since we already did it

      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: build-artifacts

      - name: Install dependencies
        run: |
          echo "Installing dependencies for testing..."
          cd backend && bun install && cd ..
          cd ui && bun install && cd ..

      - name: Test UI
        continue-on-error: ${{ !inputs.fail_on_test_failure }}
        timeout-minutes: 5
        env:
          CI: true
        run: |
          echo "Running UI tests (quick mode for CI)..."
          cd ui
          # Skip Playwright tests in CI for now since they're too slow
          echo "‚úÖ UI tests completed (skipped), TODO later"
          cd ..

      - name: Test backend
        continue-on-error: ${{ !inputs.fail_on_test_failure }}
        run: |
          echo "Running backend tests..."
          cd backend
          echo "‚è≠Ô∏è Skipping backend tests in CI for no, TODO later"
