name: Build

on:
  workflow_call:
    inputs:
      run_tests:
        description: "Whether to run tests"
        required: false
        type: boolean
        default: true
      fail_on_test_failure:
        description: "Whether to fail the workflow if tests fail"
        required: false
        type: boolean
        default: false
    secrets:
      APP_ID:
        required: false
      APP_PRIVATE_KEY:
        required: false
      OPENAI_API_KEY:
        required: false

jobs:
  build:
    name: Build Project
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Bun with version scripts
        uses: ./.github/actions/setup-bun-version
        with:
          checkout: 'false'  # Skip checkout since we already did it

      - name: Generate client APIs
        run: |
          echo "Generating client APIs..."
          bun install
          cd backend && bun install && cd ..
          cd ui && bun install && cd ..
          bun run generate:ui:normalized
          
          # Configure git for potential commits
          git config --global user.name 'github-actions[bot]'
          git config --global user.email 'github-actions[bot]@users.noreply.github.com'
          
          # Check if there are changes to commit (files should already be staged by generate:ui:normalized)
          if git diff --staged --quiet; then
            echo "No API client changes to commit"
          else
            git commit -m "ü§ñ Update client APIs from build process"
            git push
            echo "‚úÖ API client changes committed and pushed"
          fi

      - name: Combined Build & Log
        id: build
        run: |
          set -o pipefail
          (
            echo "=== Building backend ==="
            cd backend && bun install && bun run build && cd ..
            echo "=== Building UI ==="
            cd ui && bun install && bun run build && cd ..
          ) 2>&1 | tee build.log

      - name: Authenticate as GitHub App
        if: failure()
        id: app-auth
        uses: actions/create-github-app-token@v2
        with:
          app-id: ${{ secrets.APP_ID }}
          private-key: ${{ secrets.APP_PRIVATE_KEY }}
          owner: ${{ github.repository_owner }}
          repositories: ${{ github.event.repository.name }}

      - name: Auto-fix and retry build (single attempt)
        if: failure() && steps.app-auth.outputs.token
        id: auto-fix-retry
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          GITHUB_TOKEN: ${{ steps.app-auth.outputs.token }}
        run: |
          # Install curl for API calls
          curl --version || (apt-get update && apt-get install -y curl)
          
          echo "üîÑ Auto-fix attempt after build failure"
          
          # Ask GPT-4o for structured code fixes via API
          echo "üìù Analyzing build errors with AI (Structured Outputs)..."
          
          # Read build errors and create a proper JSON payload file
          BUILD_ERRORS=$(sed -n '1,2000p' "build.log")
          
          # Debug: show what we're sending to AI
          echo "üîç Build errors being sent to AI (first 500 chars):"
          echo "$BUILD_ERRORS" | head -c 500
          echo "..."
          
          # Check if we have OpenAI API key
          if [ -z "$OPENAI_API_KEY" ]; then
            echo "‚ùå OPENAI_API_KEY is not set - skipping AI fixes"
            echo "‚ö†Ô∏è No AI fixes available - continuing without fixes"
          else
            echo "‚úÖ OpenAI API key is available, making request..."
            
            # Create JSON payload with proper escaping using jq
            ESCAPED_ERRORS=$(echo "$BUILD_ERRORS" | jq -Rs .)
            jq -n --argjson errors "$ESCAPED_ERRORS" '{
              "model": "gpt-4o-2024-08-06",
              "messages": [
                {
                  "role": "system",
                  "content": "You are a code fixing assistant. Analyze build errors and provide structured fixes. Always return valid JSON with fixes array, even if empty. IMPORTANT: File paths in build errors are relative to project folders (backend/ or ui/). When providing file_path, include the full path from repository root (e.g., 'ui/src/file.tsx' not 'src/file.tsx')."
                },
                {
                  "role": "user",
                  "content": ("Fix these TypeScript/JavaScript build errors. Note: This is a monorepo with backend/ and ui/ folders. Build errors from the UI are run from the ui/ directory, so file paths like 'src/file.tsx' should be 'ui/src/file.tsx' in your fixes. Build errors from backend are run from backend/ directory, so 'src/file.ts' should be 'backend/src/file.ts':\n\n" + $errors)
                }
              ],
              "temperature": 0.1,
              "response_format": {
                "type": "json_schema",
                "json_schema": {
                  "name": "code_fixes",
                  "strict": true,
                  "schema": {
                    "type": "object",
                    "properties": {
                      "fixes": {
                        "type": "array",
                        "items": {
                          "type": "object",
                          "properties": {
                            "file_path": {
                              "type": "string",
                              "description": "Path to the file to fix"
                            },
                            "line_number": {
                              "type": "number",
                              "description": "Line number where the fix should be applied"
                            },
                            "search_text": {
                              "type": "string",
                              "description": "Exact text to search for and replace"
                            },
                            "replacement_text": {
                              "type": "string",
                              "description": "Text to replace the search text with"
                            },
                            "description": {
                              "type": "string",
                              "description": "Description of what this fix does"
                            }
                          },
                          "required": ["file_path", "line_number", "search_text", "replacement_text", "description"],
                          "additionalProperties": false
                        }
                      }
                    },
                    "required": ["fixes"],
                    "additionalProperties": false
                  }
                }
              }
            }' > openai-request.json
            
            # Make the API call using the JSON file
            API_RESPONSE=$(curl -s -w "\nHTTP_STATUS:%{http_code}" -X POST "https://api.openai.com/v1/chat/completions" \
              -H "Content-Type: application/json" \
              -H "Authorization: Bearer $OPENAI_API_KEY" \
              -d @openai-request.json)
            
            # Extract HTTP status and response body
            HTTP_STATUS=$(echo "$API_RESPONSE" | grep "HTTP_STATUS:" | cut -d: -f2)
            RESPONSE_BODY=$(echo "$API_RESPONSE" | sed '/HTTP_STATUS:/d')
            
            echo "üåê OpenAI API HTTP Status: $HTTP_STATUS"
            
            if [ "$HTTP_STATUS" = "200" ]; then
              echo "$RESPONSE_BODY" | jq -r '.choices[0].message.content' > ai-fixes.json
              echo "‚úÖ OpenAI API call successful"
            else
              echo "‚ùå OpenAI API call failed with status $HTTP_STATUS"
              echo "Response: $RESPONSE_BODY"
              echo '{"fixes":[]}' > ai-fixes.json
            fi
            
            # Clean up temporary files
            rm -f openai-request.json
          fi

          # Debug: show what the AI generated
          echo "üîç AI generated structured fixes:"
          if [ -f "ai-fixes.json" ]; then
            cat ai-fixes.json
          else
            echo "‚ùå No fix file generated"
          fi
          echo "--- End of fixes ---"

          # Apply structured fixes
          PATCH_SUCCESS=false
          if [ -s ai-fixes.json ]; then
            echo "üìÅ Fix file exists and is not empty"
            
            # Validate JSON structure
            if jq -e '.fixes' ai-fixes.json > /dev/null 2>&1; then
              echo "‚úÖ Valid structured fixes received"
              
              # Check if fixes array is not empty
              FIX_COUNT=$(jq '.fixes | length' ai-fixes.json)
              echo "üî¢ Number of fixes: $FIX_COUNT"
              
              if [ "$FIX_COUNT" -gt 0 ]; then
                # Apply each fix
                jq -r '.fixes[] | @json' ai-fixes.json | while read fix_json; do
                  file_path=$(echo "$fix_json" | jq -r '.file_path')
                  search_text=$(echo "$fix_json" | jq -r '.search_text')
                  replacement_text=$(echo "$fix_json" | jq -r '.replacement_text')
                  description=$(echo "$fix_json" | jq -r '.description')
                  
                  echo "üîß Applying fix: $description"
                  echo "üìÅ File: $file_path"
                  echo "üîç Search: $search_text"
                  echo "üîÑ Replace: $replacement_text"
                  
                  if [ -f "$file_path" ]; then
                    # Use sed to replace the exact text (escape special characters)
                    if sed -i "s|$(echo "$search_text" | sed 's/[[\.*^$()+?{|]/\\&/g')|$(echo "$replacement_text" | sed 's/[[\.*^$()+?{|]/\\&/g')|g" "$file_path" 2>/dev/null; then
                      echo "‚úÖ Fix applied successfully"
                      PATCH_SUCCESS=true
                    else
                      echo "‚ùå Failed to apply fix"
                    fi
                  else
                    echo "‚ùå File not found: $file_path"
                  fi
                done
              else
                echo "‚ÑπÔ∏è AI returned valid JSON but no fixes were suggested"
              fi
            else
              echo "‚ùå Invalid JSON structure in AI response"
              echo "Raw content:"
              cat ai-fixes.json
            fi
          else
            echo "‚ö†Ô∏è Fix file is empty or does not exist"
          fi

          # Commit fixes if any were applied
          if [ "$PATCH_SUCCESS" = "true" ]; then
            # Remove build artifacts from staging
            git reset build.log ai-fixes.json openai-request.json 2>/dev/null || true
            rm -f build.log ai-fixes.json openai-request.json 2>/dev/null || true
            
            git config user.name "github-actions[bot]"
            git config user.email "github-actions[bot]@users.noreply.github.com"
            
            # Check if there are actual code changes
            if [ -n "$(git status --porcelain | grep -v build.log | grep -v ai-fixes.json | grep -v openai-request.json)" ]; then
              git add .
              git commit -m "chore: auto-fix build errors via OpenAI [skip ci]"
              git push
              echo "‚úÖ Code fixes applied and pushed"
            else
              echo "‚ö†Ô∏è No actual code changes to commit"
            fi
          else
            echo "‚ö†Ô∏è Skipping commit - no patches applied"
          fi
          
          # Retry the build once
          echo "üîÑ Retrying build after AI fixes..."
          set +e  # Don't exit on error
          (
            echo "=== Retrying Backend Build ==="
            cd backend && bun install && bun run build && cd ..
            echo "=== Retrying UI Build ==="
            cd ui && bun install && bun run build && cd ..
          ) 2>&1 | tee retry-build.log
          
          BUILD_EXIT_CODE=$?
          set -e  # Re-enable exit on error
          
          if [ $BUILD_EXIT_CODE -eq 0 ]; then
            echo "‚úÖ Build succeeded after AI fixes!"
            echo "build_success=true" >> $GITHUB_OUTPUT
          else
            echo "‚ùå Build still failed after AI fixes"
            echo "build_success=false" >> $GITHUB_OUTPUT
            # Don't exit here, let the workflow continue to upload artifacts if needed
          fi

      - name: Upload build artifacts
        if: (success() || steps.auto-fix-retry.outputs.build_success == 'true') && !startsWith(github.ref, 'refs/heads/dev/')
        uses: actions/upload-artifact@v4
        with:
          name: build-artifacts
          path: |
            backend/dist/
            ui/dist/
          retention-days: 1

  test:
    name: Run Tests
    runs-on: ubuntu-latest
    needs: build
    if: ${{ inputs.run_tests }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Bun with version scripts
        uses: ./.github/actions/setup-bun-version
        with:
          checkout: 'false'  # Skip checkout since we already did it

      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: build-artifacts

      - name: Install dependencies
        run: |
          echo "Installing dependencies for testing..."
          cd backend && bun install && cd ..
          cd ui && bun install && cd ..

      - name: Test UI
        continue-on-error: true
        timeout-minutes: 5
        id: test-ui
        env:
          CI: true
        run: |
          echo "Running UI tests (quick mode for CI)..."
          cd ui
          # Skip Playwright tests in CI for now since they're too slow
          echo "‚úÖ UI tests completed (skipped), TODO later"
          cd ..

      - name: Test backend
        continue-on-error: true
        id: test-backend
        run: |
          echo "Running backend tests..."
          cd backend
          echo "‚è≠Ô∏è Skipping backend tests in CI for now, TODO later"
          cd ..

      - name: Auto-fix test failures (if any)
        if: steps.test-ui.outcome == 'failure' || steps.test-backend.outcome == 'failure'
        id: auto-fix-tests
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "üîÑ Auto-fix attempt after test failures"
          
          # Collect test error logs (when we have real tests)
          echo "üìù Analyzing test errors with AI (placeholder for now)..."
          echo "Test error analysis would go here when tests are implemented"
          
          # For now, just indicate no fixes needed since tests are skipped
          echo "‚ÑπÔ∏è No test fixes needed - tests are currently skipped"
          echo "test_fix_success=false" >> $GITHUB_OUTPUT

      - name: Retry tests after fixes
        if: steps.auto-fix-tests.outputs.test_fix_success == 'true'
        run: |
          echo "üîÑ Retrying tests after AI fixes..."
          
          echo "Running UI tests (retry)..."
          cd ui
          echo "‚úÖ UI tests retry completed (skipped), TODO later"
          cd ..
          
          echo "Running backend tests (retry)..."
          cd backend
          echo "‚è≠Ô∏è Backend tests retry completed (skipped), TODO later"
          cd ..
