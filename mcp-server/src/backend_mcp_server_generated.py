"""
Auto-generated FastMCP server from OpenAPI client.

This file is generated by generate_mcp_tools.py and provides
MCP protocol access to all backend API operations.

DO NOT EDIT MANUALLY - regenerate using: python src/generate_mcp_tools.py
"""

import logging
import sys
from pathlib import Path
from typing import Any

from mcp.server.fastmcp import Context, FastMCP

# Add the generated folder to the Python path (so api_client can be imported as a package)
generated_path = Path(__file__).parent / "generated"
if str(generated_path) not in sys.path:
    sys.path.insert(0, str(generated_path))

from api_client import (
    ApiClient,
    ApiException,
    Configuration,
    AdminApi,
    AiApi,
    AuthenticationApi,
    FhirApi,
    HealthcareUsersApi,
    IdentityProvidersApi,
    LaunchContextsApi,
    OauthMonitoringApi,
    RolesApi,
    ServerApi,
    ServersApi,
    SmartAppsApi,
)

from config import settings

logger = logging.getLogger(__name__)

# Create FastMCP server
mcp = FastMCP(
    name="SMART on FHIR Backend",
    instructions=(
        "This server provides tools to manage the SMART on FHIR proxy backend. "
        "Auto-generated from OpenAPI client."
    ),
)

# Initialize API client
config = Configuration(host=settings.backend_api_url)
if settings.backend_api_token:
    config.access_token = settings.backend_api_token

api_client = ApiClient(configuration=config)

# Initialize API instances (auto-discovered)
admin_api = AdminApi(api_client)
ai_api = AiApi(api_client)
authentication_api = AuthenticationApi(api_client)
fhir_api = FhirApi(api_client)
healthcare_users_api = HealthcareUsersApi(api_client)
identity_providers_api = IdentityProvidersApi(api_client)
launch_contexts_api = LaunchContextsApi(api_client)
oauth_monitoring_api = OauthMonitoringApi(api_client)
roles_api = RolesApi(api_client)
server_api = ServerApi(api_client)
servers_api = ServersApi(api_client)
smart_apps_api = SmartAppsApi(api_client)


def _format_api_error(e: ApiException) -> str:
    """Format API exception into user-friendly error message."""
    if e.status == 401:
        return "Authentication required. Please configure BACKEND_API_TOKEN."
    elif e.status == 403:
        return "Permission denied. Check your authentication token."
    elif e.status == 404:
        return "Resource not found."
    elif e.status == 500:
        return "Backend server error."
    else:
        return f"API error (status {e.status}): {e.reason}"


# Generated tool functions below
# ============================================================================



# AdminApi tools
# ======================================================================

@mcp.tool()
async def list_admin_client_registration_settings(ctx: Context) -> dict[str, Any]:
    """
    Get Dynamic Client Registration Settings
    
    Auto-generated from: admin_api.get_admin_client_registration_settings()
    """
    try:
        await ctx.info(f"Calling list_admin_client_registration_settings...")
        
        response = admin_api.get_admin_client_registration_settings()
        
        # Convert response to dict if it has to_dict method
        if hasattr(response, 'to_dict'):
            result = response.to_dict()
        elif isinstance(response, list) and response and hasattr(response[0], 'to_dict'):
            result = [item.to_dict() for item in response]
        else:
            result = response
        
        await ctx.info(f"list_admin_client_registration_settings completed successfully")
        return {"result": result}
        
    except ApiException as e:
        error_msg = _format_api_error(e)
        await ctx.error(f"Failed to execute list_admin_client_registration_settings: {error_msg}")
        return {"error": error_msg, "status": e.status}
    except Exception as e:
        await ctx.error(f"Unexpected error in list_admin_client_registration_settings: {str(e)}")
        return {"error": str(e)}

@mcp.tool()
async def list_admin_keycloak_config_status(ctx: Context) -> dict[str, Any]:
    """
    Get Keycloak Admin Configuration
    
    Auto-generated from: admin_api.get_admin_keycloak_config_status()
    """
    try:
        await ctx.info(f"Calling list_admin_keycloak_config_status...")
        
        response = admin_api.get_admin_keycloak_config_status()
        
        # Convert response to dict if it has to_dict method
        if hasattr(response, 'to_dict'):
            result = response.to_dict()
        elif isinstance(response, list) and response and hasattr(response[0], 'to_dict'):
            result = [item.to_dict() for item in response]
        else:
            result = response
        
        await ctx.info(f"list_admin_keycloak_config_status completed successfully")
        return {"result": result}
        
    except ApiException as e:
        error_msg = _format_api_error(e)
        await ctx.error(f"Failed to execute list_admin_keycloak_config_status: {error_msg}")
        return {"error": error_msg, "status": e.status}
    except Exception as e:
        await ctx.error(f"Unexpected error in list_admin_keycloak_config_status: {str(e)}")
        return {"error": str(e)}

@mcp.tool()
async def create_admin_client_registration_reset_defaults(ctx: Context) -> dict[str, Any]:
    """
    Reset Client Registration Settings to Defaults
    
    Auto-generated from: admin_api.post_admin_client_registration_reset_defaults()
    """
    try:
        await ctx.info(f"Calling create_admin_client_registration_reset_defaults...")
        
        response = admin_api.post_admin_client_registration_reset_defaults()
        
        # Convert response to dict if it has to_dict method
        if hasattr(response, 'to_dict'):
            result = response.to_dict()
        elif isinstance(response, list) and response and hasattr(response[0], 'to_dict'):
            result = [item.to_dict() for item in response]
        else:
            result = response
        
        await ctx.info(f"create_admin_client_registration_reset_defaults completed successfully")
        return {"result": result}
        
    except ApiException as e:
        error_msg = _format_api_error(e)
        await ctx.error(f"Failed to execute create_admin_client_registration_reset_defaults: {error_msg}")
        return {"error": error_msg, "status": e.status}
    except Exception as e:
        await ctx.error(f"Unexpected error in create_admin_client_registration_reset_defaults: {str(e)}")
        return {"error": str(e)}

@mcp.tool()
async def create_admin_keycloak_config_configure(ctx: Context, save_keycloak_config_request: str) -> dict[str, Any]:
    """
    Configure Keycloak Connection
    
    Parameters:
        save_keycloak_config_request: JSON object with the following fields:
  - baseUrl (REQUIRED): Keycloak base URL
  - realm (REQUIRED): Keycloak realm name
  - adminClientId (optional): Admin client ID for API access
  - adminClientSecret (optional): Admin client secret for API access
  - additional_properties (optional)
    
    Example JSON for parameters:
      save_keycloak_config_request:
        {
          "baseUrl": "<base_url>",
          "realm": "<realm>"
        }
    
    Auto-generated from: admin_api.post_admin_keycloak_config_configure()
    """
    try:
        await ctx.info(f"Calling create_admin_keycloak_config_configure...")
        from api_client.models import SaveKeycloakConfigRequest
        # Convert JSON string to Pydantic model
        import json
        save_keycloak_config_request_data = json.loads(save_keycloak_config_request) if isinstance(save_keycloak_config_request, str) else save_keycloak_config_request
        save_keycloak_config_request_obj = SaveKeycloakConfigRequest(**save_keycloak_config_request_data)

        
        response = admin_api.post_admin_keycloak_config_configure(save_keycloak_config_request=save_keycloak_config_request_obj)
        
        # Convert response to dict if it has to_dict method
        if hasattr(response, 'to_dict'):
            result = response.to_dict()
        elif isinstance(response, list) and response and hasattr(response[0], 'to_dict'):
            result = [item.to_dict() for item in response]
        else:
            result = response
        
        await ctx.info(f"create_admin_keycloak_config_configure completed successfully")
        return {"result": result}
        
    except ApiException as e:
        error_msg = _format_api_error(e)
        await ctx.error(f"Failed to execute create_admin_keycloak_config_configure: {error_msg}")
        return {"error": error_msg, "status": e.status}
    except Exception as e:
        await ctx.error(f"Unexpected error in create_admin_keycloak_config_configure: {str(e)}")
        return {"error": str(e)}

@mcp.tool()
async def create_admin_keycloak_config_test(ctx: Context, test_keycloak_connection_request: str) -> dict[str, Any]:
    """
    Test Keycloak Connection
    
    Parameters:
        test_keycloak_connection_request: JSON object with the following fields:
  - baseUrl (REQUIRED): Keycloak base URL
  - realm (REQUIRED): Keycloak realm name
  - additional_properties (optional)
    
    Example JSON for parameters:
      test_keycloak_connection_request:
        {
          "baseUrl": "<base_url>",
          "realm": "<realm>"
        }
    
    Auto-generated from: admin_api.post_admin_keycloak_config_test()
    """
    try:
        await ctx.info(f"Calling create_admin_keycloak_config_test...")
        from api_client.models import TestKeycloakConnectionRequest
        # Convert JSON string to Pydantic model
        import json
        test_keycloak_connection_request_data = json.loads(test_keycloak_connection_request) if isinstance(test_keycloak_connection_request, str) else test_keycloak_connection_request
        test_keycloak_connection_request_obj = TestKeycloakConnectionRequest(**test_keycloak_connection_request_data)

        
        response = admin_api.post_admin_keycloak_config_test(test_keycloak_connection_request=test_keycloak_connection_request_obj)
        
        # Convert response to dict if it has to_dict method
        if hasattr(response, 'to_dict'):
            result = response.to_dict()
        elif isinstance(response, list) and response and hasattr(response[0], 'to_dict'):
            result = [item.to_dict() for item in response]
        else:
            result = response
        
        await ctx.info(f"create_admin_keycloak_config_test completed successfully")
        return {"result": result}
        
    except ApiException as e:
        error_msg = _format_api_error(e)
        await ctx.error(f"Failed to execute create_admin_keycloak_config_test: {error_msg}")
        return {"error": error_msg, "status": e.status}
    except Exception as e:
        await ctx.error(f"Unexpected error in create_admin_keycloak_config_test: {str(e)}")
        return {"error": str(e)}

@mcp.tool()
async def create_admin_restart(ctx: Context) -> dict[str, Any]:
    """
    Restart Server
    
    Auto-generated from: admin_api.post_admin_restart()
    """
    try:
        await ctx.info(f"Calling create_admin_restart...")
        
        response = admin_api.post_admin_restart()
        
        # Convert response to dict if it has to_dict method
        if hasattr(response, 'to_dict'):
            result = response.to_dict()
        elif isinstance(response, list) and response and hasattr(response[0], 'to_dict'):
            result = [item.to_dict() for item in response]
        else:
            result = response
        
        await ctx.info(f"create_admin_restart completed successfully")
        return {"result": result}
        
    except ApiException as e:
        error_msg = _format_api_error(e)
        await ctx.error(f"Failed to execute create_admin_restart: {error_msg}")
        return {"error": error_msg, "status": e.status}
    except Exception as e:
        await ctx.error(f"Unexpected error in create_admin_restart: {str(e)}")
        return {"error": str(e)}

@mcp.tool()
async def create_admin_shutdown(ctx: Context) -> dict[str, Any]:
    """
    Shutdown Server
    
    Auto-generated from: admin_api.post_admin_shutdown()
    """
    try:
        await ctx.info(f"Calling create_admin_shutdown...")
        
        response = admin_api.post_admin_shutdown()
        
        # Convert response to dict if it has to_dict method
        if hasattr(response, 'to_dict'):
            result = response.to_dict()
        elif isinstance(response, list) and response and hasattr(response[0], 'to_dict'):
            result = [item.to_dict() for item in response]
        else:
            result = response
        
        await ctx.info(f"create_admin_shutdown completed successfully")
        return {"result": result}
        
    except ApiException as e:
        error_msg = _format_api_error(e)
        await ctx.error(f"Failed to execute create_admin_shutdown: {error_msg}")
        return {"error": error_msg, "status": e.status}
    except Exception as e:
        await ctx.error(f"Unexpected error in create_admin_shutdown: {str(e)}")
        return {"error": str(e)}

@mcp.tool()
async def create_admin_smart_config_refresh(ctx: Context) -> dict[str, Any]:
    """
    Refresh SMART Configuration Cache
    
    Auto-generated from: admin_api.post_admin_smart_config_refresh()
    """
    try:
        await ctx.info(f"Calling create_admin_smart_config_refresh...")
        
        response = admin_api.post_admin_smart_config_refresh()
        
        # Convert response to dict if it has to_dict method
        if hasattr(response, 'to_dict'):
            result = response.to_dict()
        elif isinstance(response, list) and response and hasattr(response[0], 'to_dict'):
            result = [item.to_dict() for item in response]
        else:
            result = response
        
        await ctx.info(f"create_admin_smart_config_refresh completed successfully")
        return {"result": result}
        
    except ApiException as e:
        error_msg = _format_api_error(e)
        await ctx.error(f"Failed to execute create_admin_smart_config_refresh: {error_msg}")
        return {"error": error_msg, "status": e.status}
    except Exception as e:
        await ctx.error(f"Unexpected error in create_admin_smart_config_refresh: {str(e)}")
        return {"error": str(e)}

@mcp.tool()
async def update_admin_client_registration_settings(ctx: Context, client_registration_settings: str) -> dict[str, Any]:
    """
    Update Dynamic Client Registration Settings
    
    Parameters:
        client_registration_settings: JSON object with the following fields:
  - enabled (REQUIRED): Whether dynamic client registration is enabled
  - requireHttps (REQUIRED): Whether HTTPS is required for redirect URIs
  - allowedScopes (REQUIRED)
  - maxClientLifetime (REQUIRED): Maximum client lifetime in days (0 = no limit)
  - requireTermsOfService (REQUIRED): Whether terms of service URI is required
  - requirePrivacyPolicy (REQUIRED): Whether privacy policy URI is required
  - allowPublicClients (REQUIRED): Whether public clients are allowed
  - allowConfidentialClients (REQUIRED): Whether confidential clients are allowed
  - allowBackendServices (REQUIRED): Whether backend service clients are allowed
  - adminApprovalRequired (REQUIRED): Whether admin approval is required for new registrations
  - rateLimitPerMinute (REQUIRED): Rate limit for registration requests per minute
  - maxRedirectUris (REQUIRED): Maximum number of redirect URIs allowed per client
  - allowedRedirectUriPatterns (REQUIRED)
  - notificationEmail (optional): Email to notify of new registrations
  - additional_properties (optional)
    
    Example JSON for parameters:
      client_registration_settings:
        {
          "enabled": false,
          "requireHttps": false,
          "allowedScopes": "<allowed_scopes>",
          "maxClientLifetime": "<max_client_lifetime>",
          "requireTermsOfService": false,
          "requirePrivacyPolicy": false,
          "allowPublicClients": false,
          "allowConfidentialClients": false,
          "allowBackendServices": false,
          "adminApprovalRequired": false,
          "rateLimitPerMinute": "<rate_limit_per_minute>",
          "maxRedirectUris": "<max_redirect_uris>",
          "allowedRedirectUriPatterns": "<allowed_redirect_uri_patterns>"
        }
    
    Auto-generated from: admin_api.put_admin_client_registration_settings()
    """
    try:
        await ctx.info(f"Calling update_admin_client_registration_settings...")
        from api_client.models import ClientRegistrationSettings
        # Convert JSON string to Pydantic model
        import json
        client_registration_settings_data = json.loads(client_registration_settings) if isinstance(client_registration_settings, str) else client_registration_settings
        client_registration_settings_obj = ClientRegistrationSettings(**client_registration_settings_data)

        
        response = admin_api.put_admin_client_registration_settings(client_registration_settings=client_registration_settings_obj)
        
        # Convert response to dict if it has to_dict method
        if hasattr(response, 'to_dict'):
            result = response.to_dict()
        elif isinstance(response, list) and response and hasattr(response[0], 'to_dict'):
            result = [item.to_dict() for item in response]
        else:
            result = response
        
        await ctx.info(f"update_admin_client_registration_settings completed successfully")
        return {"result": result}
        
    except ApiException as e:
        error_msg = _format_api_error(e)
        await ctx.error(f"Failed to execute update_admin_client_registration_settings: {error_msg}")
        return {"error": error_msg, "status": e.status}
    except Exception as e:
        await ctx.error(f"Unexpected error in update_admin_client_registration_settings: {str(e)}")
        return {"error": str(e)}


# AiApi tools
# ======================================================================

@mcp.tool()
async def list_ai_health(ctx: Context) -> dict[str, Any]:
    """
    Get AI assistant health status
    
    Auto-generated from: ai_api.get_ai_health()
    """
    try:
        await ctx.info(f"Calling list_ai_health...")
        
        response = ai_api.get_ai_health()
        
        # Convert response to dict if it has to_dict method
        if hasattr(response, 'to_dict'):
            result = response.to_dict()
        elif isinstance(response, list) and response and hasattr(response[0], 'to_dict'):
            result = [item.to_dict() for item in response]
        else:
            result = response
        
        await ctx.info(f"list_ai_health completed successfully")
        return {"result": result}
        
    except ApiException as e:
        error_msg = _format_api_error(e)
        await ctx.error(f"Failed to execute list_ai_health: {error_msg}")
        return {"error": error_msg, "status": e.status}
    except Exception as e:
        await ctx.error(f"Unexpected error in list_ai_health: {str(e)}")
        return {"error": str(e)}

@mcp.tool()
async def head_ai_chat(ctx: Context) -> dict[str, Any]:
    """
    Check AI assistant availability
    
    Auto-generated from: ai_api.head_ai_chat()
    """
    try:
        await ctx.info(f"Calling head_ai_chat...")
        
        response = ai_api.head_ai_chat()
        
        # Convert response to dict if it has to_dict method
        if hasattr(response, 'to_dict'):
            result = response.to_dict()
        elif isinstance(response, list) and response and hasattr(response[0], 'to_dict'):
            result = [item.to_dict() for item in response]
        else:
            result = response
        
        await ctx.info(f"head_ai_chat completed successfully")
        return {"result": result}
        
    except ApiException as e:
        error_msg = _format_api_error(e)
        await ctx.error(f"Failed to execute head_ai_chat: {error_msg}")
        return {"error": error_msg, "status": e.status}
    except Exception as e:
        await ctx.error(f"Unexpected error in head_ai_chat: {str(e)}")
        return {"error": str(e)}

@mcp.tool()
async def create_ai_chat(ctx: Context, chat_request: str) -> dict[str, Any]:
    """
    Proxy AI assistant chat request
    
    Parameters:
        chat_request: JSON object with the following fields:
  - message (REQUIRED): User message/question
  - conversationId (optional): Conversation ID for context
  - pageContext (optional): Current page context
  - additional_properties (optional)
    
    Example JSON for parameters:
      chat_request:
        {
          "message": "<message>"
        }
    
    Auto-generated from: ai_api.post_ai_chat()
    """
    try:
        await ctx.info(f"Calling create_ai_chat...")
        from api_client.models import ChatRequest
        # Convert JSON string to Pydantic model
        import json
        chat_request_data = json.loads(chat_request) if isinstance(chat_request, str) else chat_request
        chat_request_obj = ChatRequest(**chat_request_data)

        
        response = ai_api.post_ai_chat(chat_request=chat_request_obj)
        
        # Convert response to dict if it has to_dict method
        if hasattr(response, 'to_dict'):
            result = response.to_dict()
        elif isinstance(response, list) and response and hasattr(response[0], 'to_dict'):
            result = [item.to_dict() for item in response]
        else:
            result = response
        
        await ctx.info(f"create_ai_chat completed successfully")
        return {"result": result}
        
    except ApiException as e:
        error_msg = _format_api_error(e)
        await ctx.error(f"Failed to execute create_ai_chat: {error_msg}")
        return {"error": error_msg, "status": e.status}
    except Exception as e:
        await ctx.error(f"Unexpected error in create_ai_chat: {str(e)}")
        return {"error": str(e)}

@mcp.tool()
async def create_ai_chat_stream(ctx: Context, chat_request: str) -> dict[str, Any]:
    """
    Proxy AI assistant streaming chat request
    
    Parameters:
        chat_request: JSON object with the following fields:
  - message (REQUIRED): User message/question
  - conversationId (optional): Conversation ID for context
  - pageContext (optional): Current page context
  - additional_properties (optional)
    
    Example JSON for parameters:
      chat_request:
        {
          "message": "<message>"
        }
    
    Auto-generated from: ai_api.post_ai_chat_stream()
    """
    try:
        await ctx.info(f"Calling create_ai_chat_stream...")
        from api_client.models import ChatRequest
        # Convert JSON string to Pydantic model
        import json
        chat_request_data = json.loads(chat_request) if isinstance(chat_request, str) else chat_request
        chat_request_obj = ChatRequest(**chat_request_data)

        
        response = ai_api.post_ai_chat_stream(chat_request=chat_request_obj)
        
        # Convert response to dict if it has to_dict method
        if hasattr(response, 'to_dict'):
            result = response.to_dict()
        elif isinstance(response, list) and response and hasattr(response[0], 'to_dict'):
            result = [item.to_dict() for item in response]
        else:
            result = response
        
        await ctx.info(f"create_ai_chat_stream completed successfully")
        return {"result": result}
        
    except ApiException as e:
        error_msg = _format_api_error(e)
        await ctx.error(f"Failed to execute create_ai_chat_stream: {error_msg}")
        return {"error": error_msg, "status": e.status}
    except Exception as e:
        await ctx.error(f"Unexpected error in create_ai_chat_stream: {str(e)}")
        return {"error": str(e)}


# AuthenticationApi tools
# ======================================================================

@mcp.tool()
async def list_auth_authorize(ctx: Context, response_type: str | None = None, client_id: str | None = None, redirect_uri: str | None = None, scope: str | None = None, state: str | None = None, code_challenge: str | None = None, code_challenge_method: str | None = None, authorization_details: str | None = None, kc_idp_hint: str | None = None) -> dict[str, Any]:
    """
    OAuth Authorization Endpoint
    
    Parameters:
        response_type: Parameter: response_type
        client_id: Parameter: client_id
        redirect_uri: Parameter: redirect_uri
        scope: Parameter: scope
        state: Parameter: state
        code_challenge: Parameter: code_challenge
        code_challenge_method: Parameter: code_challenge_method
        authorization_details: Parameter: authorization_details
        kc_idp_hint: Parameter: kc_idp_hint
    
    Auto-generated from: authentication_api.get_auth_authorize()
    """
    try:
        await ctx.info(f"Calling list_auth_authorize...")
        
        response = authentication_api.get_auth_authorize(response_type=response_type, client_id=client_id, redirect_uri=redirect_uri, scope=scope, state=state, code_challenge=code_challenge, code_challenge_method=code_challenge_method, authorization_details=authorization_details, kc_idp_hint=kc_idp_hint)
        
        # Convert response to dict if it has to_dict method
        if hasattr(response, 'to_dict'):
            result = response.to_dict()
        elif isinstance(response, list) and response and hasattr(response[0], 'to_dict'):
            result = [item.to_dict() for item in response]
        else:
            result = response
        
        await ctx.info(f"list_auth_authorize completed successfully")
        return {"result": result}
        
    except ApiException as e:
        error_msg = _format_api_error(e)
        await ctx.error(f"Failed to execute list_auth_authorize: {error_msg}")
        return {"error": error_msg, "status": e.status}
    except Exception as e:
        await ctx.error(f"Unexpected error in list_auth_authorize: {str(e)}")
        return {"error": str(e)}

@mcp.tool()
async def list_auth_config(ctx: Context) -> dict[str, Any]:
    """
    Get authentication configuration
    
    Auto-generated from: authentication_api.get_auth_config()
    """
    try:
        await ctx.info(f"Calling list_auth_config...")
        
        response = authentication_api.get_auth_config()
        
        # Convert response to dict if it has to_dict method
        if hasattr(response, 'to_dict'):
            result = response.to_dict()
        elif isinstance(response, list) and response and hasattr(response[0], 'to_dict'):
            result = [item.to_dict() for item in response]
        else:
            result = response
        
        await ctx.info(f"list_auth_config completed successfully")
        return {"result": result}
        
    except ApiException as e:
        error_msg = _format_api_error(e)
        await ctx.error(f"Failed to execute list_auth_config: {error_msg}")
        return {"error": error_msg, "status": e.status}
    except Exception as e:
        await ctx.error(f"Unexpected error in list_auth_config: {str(e)}")
        return {"error": str(e)}

@mcp.tool()
async def list_auth_identity_providers(ctx: Context) -> dict[str, Any]:
    """
    Get Public Identity Providers
    
    Auto-generated from: authentication_api.get_auth_identity_providers()
    """
    try:
        await ctx.info(f"Calling list_auth_identity_providers...")
        
        response = authentication_api.get_auth_identity_providers()
        
        # Convert response to dict if it has to_dict method
        if hasattr(response, 'to_dict'):
            result = response.to_dict()
        elif isinstance(response, list) and response and hasattr(response[0], 'to_dict'):
            result = [item.to_dict() for item in response]
        else:
            result = response
        
        await ctx.info(f"list_auth_identity_providers completed successfully")
        return {"result": result}
        
    except ApiException as e:
        error_msg = _format_api_error(e)
        await ctx.error(f"Failed to execute list_auth_identity_providers: {error_msg}")
        return {"error": error_msg, "status": e.status}
    except Exception as e:
        await ctx.error(f"Unexpected error in list_auth_identity_providers: {str(e)}")
        return {"error": str(e)}

@mcp.tool()
async def list_auth_login(ctx: Context, client_id: str | None = None, redirect_uri: str | None = None, scope: str | None = None, state: str | None = None, code_challenge: str | None = None, code_challenge_method: str | None = None, authorization_details: str | None = None) -> dict[str, Any]:
    """
    Login Page Redirect
    
    Parameters:
        client_id: Parameter: client_id
        redirect_uri: Parameter: redirect_uri
        scope: Parameter: scope
        state: Parameter: state
        code_challenge: Parameter: code_challenge
        code_challenge_method: Parameter: code_challenge_method
        authorization_details: Parameter: authorization_details
    
    Auto-generated from: authentication_api.get_auth_login()
    """
    try:
        await ctx.info(f"Calling list_auth_login...")
        
        response = authentication_api.get_auth_login(client_id=client_id, redirect_uri=redirect_uri, scope=scope, state=state, code_challenge=code_challenge, code_challenge_method=code_challenge_method, authorization_details=authorization_details)
        
        # Convert response to dict if it has to_dict method
        if hasattr(response, 'to_dict'):
            result = response.to_dict()
        elif isinstance(response, list) and response and hasattr(response[0], 'to_dict'):
            result = [item.to_dict() for item in response]
        else:
            result = response
        
        await ctx.info(f"list_auth_login completed successfully")
        return {"result": result}
        
    except ApiException as e:
        error_msg = _format_api_error(e)
        await ctx.error(f"Failed to execute list_auth_login: {error_msg}")
        return {"error": error_msg, "status": e.status}
    except Exception as e:
        await ctx.error(f"Unexpected error in list_auth_login: {str(e)}")
        return {"error": str(e)}

@mcp.tool()
async def list_auth_logout(ctx: Context, post_logout_redirect_uri: str | None = None, id_token_hint: str | None = None, client_id: str | None = None) -> dict[str, Any]:
    """
    Logout Endpoint
    
    Parameters:
        post_logout_redirect_uri: Parameter: post_logout_redirect_uri
        id_token_hint: Parameter: id_token_hint
        client_id: Parameter: client_id
    
    Auto-generated from: authentication_api.get_auth_logout()
    """
    try:
        await ctx.info(f"Calling list_auth_logout...")
        
        response = authentication_api.get_auth_logout(post_logout_redirect_uri=post_logout_redirect_uri, id_token_hint=id_token_hint, client_id=client_id)
        
        # Convert response to dict if it has to_dict method
        if hasattr(response, 'to_dict'):
            result = response.to_dict()
        elif isinstance(response, list) and response and hasattr(response[0], 'to_dict'):
            result = [item.to_dict() for item in response]
        else:
            result = response
        
        await ctx.info(f"list_auth_logout completed successfully")
        return {"result": result}
        
    except ApiException as e:
        error_msg = _format_api_error(e)
        await ctx.error(f"Failed to execute list_auth_logout: {error_msg}")
        return {"error": error_msg, "status": e.status}
    except Exception as e:
        await ctx.error(f"Unexpected error in list_auth_logout: {str(e)}")
        return {"error": str(e)}

@mcp.tool()
async def list_auth_userinfo(ctx: Context, authorization: str) -> dict[str, Any]:
    """
    Get Current User Profile
    
    Parameters:
        authorization: Parameter: authorization
    
    Auto-generated from: authentication_api.get_auth_userinfo()
    """
    try:
        await ctx.info(f"Calling list_auth_userinfo...")
        
        response = authentication_api.get_auth_userinfo(authorization=authorization)
        
        # Convert response to dict if it has to_dict method
        if hasattr(response, 'to_dict'):
            result = response.to_dict()
        elif isinstance(response, list) and response and hasattr(response[0], 'to_dict'):
            result = [item.to_dict() for item in response]
        else:
            result = response
        
        await ctx.info(f"list_auth_userinfo completed successfully")
        return {"result": result}
        
    except ApiException as e:
        error_msg = _format_api_error(e)
        await ctx.error(f"Failed to execute list_auth_userinfo: {error_msg}")
        return {"error": error_msg, "status": e.status}
    except Exception as e:
        await ctx.error(f"Unexpected error in list_auth_userinfo: {str(e)}")
        return {"error": str(e)}

@mcp.tool()
async def create_auth_introspect(ctx: Context, introspect_request: str) -> dict[str, Any]:
    """
    Token Introspection
    
    Parameters:
        introspect_request: JSON object with the following fields:
  - token (REQUIRED): Token to introspect
  - token_type_hint (optional): Hint about token type (access_token, refresh_token)
  - client_id (optional): OAuth2 client ID
  - client_secret (optional): OAuth2 client secret
  - additional_properties (optional)
    
    Example JSON for parameters:
      introspect_request:
        {
          "token": "<token>"
        }
    
    Auto-generated from: authentication_api.post_auth_introspect()
    """
    try:
        await ctx.info(f"Calling create_auth_introspect...")
        from api_client.models import IntrospectRequest
        # Convert JSON string to Pydantic model
        import json
        introspect_request_data = json.loads(introspect_request) if isinstance(introspect_request, str) else introspect_request
        introspect_request_obj = IntrospectRequest(**introspect_request_data)

        
        response = authentication_api.post_auth_introspect(introspect_request=introspect_request_obj)
        
        # Convert response to dict if it has to_dict method
        if hasattr(response, 'to_dict'):
            result = response.to_dict()
        elif isinstance(response, list) and response and hasattr(response[0], 'to_dict'):
            result = [item.to_dict() for item in response]
        else:
            result = response
        
        await ctx.info(f"create_auth_introspect completed successfully")
        return {"result": result}
        
    except ApiException as e:
        error_msg = _format_api_error(e)
        await ctx.error(f"Failed to execute create_auth_introspect: {error_msg}")
        return {"error": error_msg, "status": e.status}
    except Exception as e:
        await ctx.error(f"Unexpected error in create_auth_introspect: {str(e)}")
        return {"error": str(e)}

@mcp.tool()
async def create_auth_register(ctx: Context, client_registration_request: str) -> dict[str, Any]:
    """
    Dynamic Client Registration
    
    Parameters:
        client_registration_request: JSON object with the following fields:
  - redirect_uris (REQUIRED): Array of redirect URIs for the client
  - client_name (optional): Human-readable client name
  - client_uri (optional): Client home page URL
  - logo_uri (optional): Client logo URL
  - scope (optional): Requested scopes (space-separated)
  - contacts (optional): Contact email addresses
  - tos_uri (optional): Terms of service URL
  - policy_uri (optional): Privacy policy URL
  - jwks_uri (optional): JWKS endpoint URL
  - jwks (optional): JSON Web Key Set
  - software_id (optional): Software identifier
  - software_version (optional): Software version
  - fhir_versions (optional): Supported FHIR versions
  - launch_uris (optional): EHR launch URLs
  - additional_properties (optional)
    
    Example JSON for parameters:
      client_registration_request:
        {
          "redirect_uris": "<redirect_uris>"
        }
    
    Auto-generated from: authentication_api.post_auth_register()
    """
    try:
        await ctx.info(f"Calling create_auth_register...")
        from api_client.models import ClientRegistrationRequest
        # Convert JSON string to Pydantic model
        import json
        client_registration_request_data = json.loads(client_registration_request) if isinstance(client_registration_request, str) else client_registration_request
        client_registration_request_obj = ClientRegistrationRequest(**client_registration_request_data)

        
        response = authentication_api.post_auth_register(client_registration_request=client_registration_request_obj)
        
        # Convert response to dict if it has to_dict method
        if hasattr(response, 'to_dict'):
            result = response.to_dict()
        elif isinstance(response, list) and response and hasattr(response[0], 'to_dict'):
            result = [item.to_dict() for item in response]
        else:
            result = response
        
        await ctx.info(f"create_auth_register completed successfully")
        return {"result": result}
        
    except ApiException as e:
        error_msg = _format_api_error(e)
        await ctx.error(f"Failed to execute create_auth_register: {error_msg}")
        return {"error": error_msg, "status": e.status}
    except Exception as e:
        await ctx.error(f"Unexpected error in create_auth_register: {str(e)}")
        return {"error": str(e)}

@mcp.tool()
async def create_auth_token(ctx: Context, token_request: str) -> dict[str, Any]:
    """
    OAuth Token Exchange
    
    Parameters:
        token_request: JSON object with the following fields:
  - grant_type (REQUIRED): OAuth2 grant type (authorization_code, refresh_token, client_credentials, password)
  - code (optional): Authorization code (for authorization_code grant)
  - redirect_uri (optional): Redirect URI used in authorization request
  - client_id (optional): OAuth2 client ID
  - client_secret (optional): OAuth2 client secret
  - code_verifier (optional): PKCE code verifier
  - refresh_token (optional): Refresh token (for refresh_token grant)
  - scope (optional): Requested scopes (space-separated)
  - audience (optional): Target audience for the token
  - username (optional): Username (for password grant)
  - password (optional): Password (for password grant)
  - client_assertion_type (optional): Client assertion type for JWT authentication
  - client_assertion (optional): Client assertion JWT for authentication
  - additional_properties (optional)
    
    Example JSON for parameters:
      token_request:
        {
          "grant_type": "<grant_type>"
        }
    
    Auto-generated from: authentication_api.post_auth_token()
    """
    try:
        await ctx.info(f"Calling create_auth_token...")
        from api_client.models import TokenRequest
        # Convert JSON string to Pydantic model
        import json
        token_request_data = json.loads(token_request) if isinstance(token_request, str) else token_request
        token_request_obj = TokenRequest(**token_request_data)

        
        response = authentication_api.post_auth_token(token_request=token_request_obj)
        
        # Convert response to dict if it has to_dict method
        if hasattr(response, 'to_dict'):
            result = response.to_dict()
        elif isinstance(response, list) and response and hasattr(response[0], 'to_dict'):
            result = [item.to_dict() for item in response]
        else:
            result = response
        
        await ctx.info(f"create_auth_token completed successfully")
        return {"result": result}
        
    except ApiException as e:
        error_msg = _format_api_error(e)
        await ctx.error(f"Failed to execute create_auth_token: {error_msg}")
        return {"error": error_msg, "status": e.status}
    except Exception as e:
        await ctx.error(f"Unexpected error in create_auth_token: {str(e)}")
        return {"error": str(e)}


# FhirApi tools
# ======================================================================

@mcp.tool()
async def delete_proxy_smart_backend_by_server_name_by_fhir_version(ctx: Context, server_name: str, fhir_version: str) -> dict[str, Any]:
    """
    FHIR Resource Proxy
    
    Parameters:
        server_name: Parameter: server_name
        fhir_version: Parameter: fhir_version
    
    Auto-generated from: fhir_api.delete_proxy_smart_backend_by_server_name_by_fhir_version()
    """
    try:
        await ctx.info(f"Calling delete_proxy_smart_backend_by_server_name_by_fhir_version...")
        
        response = fhir_api.delete_proxy_smart_backend_by_server_name_by_fhir_version(server_name=server_name, fhir_version=fhir_version)
        
        # Convert response to dict if it has to_dict method
        if hasattr(response, 'to_dict'):
            result = response.to_dict()
        elif isinstance(response, list) and response and hasattr(response[0], 'to_dict'):
            result = [item.to_dict() for item in response]
        else:
            result = response
        
        await ctx.info(f"delete_proxy_smart_backend_by_server_name_by_fhir_version completed successfully")
        return {"result": result}
        
    except ApiException as e:
        error_msg = _format_api_error(e)
        await ctx.error(f"Failed to execute delete_proxy_smart_backend_by_server_name_by_fhir_version: {error_msg}")
        return {"error": error_msg, "status": e.status}
    except Exception as e:
        await ctx.error(f"Unexpected error in delete_proxy_smart_backend_by_server_name_by_fhir_version: {str(e)}")
        return {"error": str(e)}

@mcp.tool()
async def get_proxy_smart_backend_by_server_name_by_fhir_version(ctx: Context, server_name: str, fhir_version: str) -> dict[str, Any]:
    """
    FHIR Server Base URL
    
    Parameters:
        server_name: Parameter: server_name
        fhir_version: Parameter: fhir_version
    
    Auto-generated from: fhir_api.get_proxy_smart_backend_by_server_name_by_fhir_version()
    """
    try:
        await ctx.info(f"Calling get_proxy_smart_backend_by_server_name_by_fhir_version...")
        
        response = fhir_api.get_proxy_smart_backend_by_server_name_by_fhir_version(server_name=server_name, fhir_version=fhir_version)
        
        # Convert response to dict if it has to_dict method
        if hasattr(response, 'to_dict'):
            result = response.to_dict()
        elif isinstance(response, list) and response and hasattr(response[0], 'to_dict'):
            result = [item.to_dict() for item in response]
        else:
            result = response
        
        await ctx.info(f"get_proxy_smart_backend_by_server_name_by_fhir_version completed successfully")
        return {"result": result}
        
    except ApiException as e:
        error_msg = _format_api_error(e)
        await ctx.error(f"Failed to execute get_proxy_smart_backend_by_server_name_by_fhir_version: {error_msg}")
        return {"error": error_msg, "status": e.status}
    except Exception as e:
        await ctx.error(f"Unexpected error in get_proxy_smart_backend_by_server_name_by_fhir_version: {str(e)}")
        return {"error": str(e)}

@mcp.tool()
async def get_proxy_smart_backend_by_server_name_by_fhir_version_0(ctx: Context, server_name: str, fhir_version: str) -> dict[str, Any]:
    """
    FHIR Resource Proxy
    
    Parameters:
        server_name: Parameter: server_name
        fhir_version: Parameter: fhir_version
    
    Auto-generated from: fhir_api.get_proxy_smart_backend_by_server_name_by_fhir_version_0()
    """
    try:
        await ctx.info(f"Calling get_proxy_smart_backend_by_server_name_by_fhir_version_0...")
        
        response = fhir_api.get_proxy_smart_backend_by_server_name_by_fhir_version_0(server_name=server_name, fhir_version=fhir_version)
        
        # Convert response to dict if it has to_dict method
        if hasattr(response, 'to_dict'):
            result = response.to_dict()
        elif isinstance(response, list) and response and hasattr(response[0], 'to_dict'):
            result = [item.to_dict() for item in response]
        else:
            result = response
        
        await ctx.info(f"get_proxy_smart_backend_by_server_name_by_fhir_version_0 completed successfully")
        return {"result": result}
        
    except ApiException as e:
        error_msg = _format_api_error(e)
        await ctx.error(f"Failed to execute get_proxy_smart_backend_by_server_name_by_fhir_version_0: {error_msg}")
        return {"error": error_msg, "status": e.status}
    except Exception as e:
        await ctx.error(f"Unexpected error in get_proxy_smart_backend_by_server_name_by_fhir_version_0: {str(e)}")
        return {"error": str(e)}

@mcp.tool()
async def update_proxy_smart_backend_by_server_name_by_fhir_version(ctx: Context, server_name: str, fhir_version: str) -> dict[str, Any]:
    """
    FHIR Resource Proxy
    
    Parameters:
        server_name: Parameter: server_name
        fhir_version: Parameter: fhir_version
    
    Auto-generated from: fhir_api.patch_proxy_smart_backend_by_server_name_by_fhir_version()
    """
    try:
        await ctx.info(f"Calling update_proxy_smart_backend_by_server_name_by_fhir_version...")
        
        response = fhir_api.patch_proxy_smart_backend_by_server_name_by_fhir_version(server_name=server_name, fhir_version=fhir_version)
        
        # Convert response to dict if it has to_dict method
        if hasattr(response, 'to_dict'):
            result = response.to_dict()
        elif isinstance(response, list) and response and hasattr(response[0], 'to_dict'):
            result = [item.to_dict() for item in response]
        else:
            result = response
        
        await ctx.info(f"update_proxy_smart_backend_by_server_name_by_fhir_version completed successfully")
        return {"result": result}
        
    except ApiException as e:
        error_msg = _format_api_error(e)
        await ctx.error(f"Failed to execute update_proxy_smart_backend_by_server_name_by_fhir_version: {error_msg}")
        return {"error": error_msg, "status": e.status}
    except Exception as e:
        await ctx.error(f"Unexpected error in update_proxy_smart_backend_by_server_name_by_fhir_version: {str(e)}")
        return {"error": str(e)}

@mcp.tool()
async def create_proxy_smart_backend_by_server_name_by_fhir_version(ctx: Context, server_name: str, fhir_version: str) -> dict[str, Any]:
    """
    FHIR Resource Proxy
    
    Parameters:
        server_name: Parameter: server_name
        fhir_version: Parameter: fhir_version
    
    Auto-generated from: fhir_api.post_proxy_smart_backend_by_server_name_by_fhir_version()
    """
    try:
        await ctx.info(f"Calling create_proxy_smart_backend_by_server_name_by_fhir_version...")
        
        response = fhir_api.post_proxy_smart_backend_by_server_name_by_fhir_version(server_name=server_name, fhir_version=fhir_version)
        
        # Convert response to dict if it has to_dict method
        if hasattr(response, 'to_dict'):
            result = response.to_dict()
        elif isinstance(response, list) and response and hasattr(response[0], 'to_dict'):
            result = [item.to_dict() for item in response]
        else:
            result = response
        
        await ctx.info(f"create_proxy_smart_backend_by_server_name_by_fhir_version completed successfully")
        return {"result": result}
        
    except ApiException as e:
        error_msg = _format_api_error(e)
        await ctx.error(f"Failed to execute create_proxy_smart_backend_by_server_name_by_fhir_version: {error_msg}")
        return {"error": error_msg, "status": e.status}
    except Exception as e:
        await ctx.error(f"Unexpected error in create_proxy_smart_backend_by_server_name_by_fhir_version: {str(e)}")
        return {"error": str(e)}

@mcp.tool()
async def create_proxy_backend_by_server_name_by_fhir_version_refresh(ctx: Context, server_name: str, fhir_version: str) -> dict[str, Any]:
    """
    Refresh FHIR Server Cache
    
    Parameters:
        server_name: Parameter: server_name
        fhir_version: Parameter: fhir_version
    
    Auto-generated from: fhir_api.post_proxy_smart_backend_by_server_name_by_fhir_version_cache_refresh()
    """
    try:
        await ctx.info(f"Calling create_proxy_backend_by_server_name_by_fhir_version_refresh...")
        
        response = fhir_api.post_proxy_smart_backend_by_server_name_by_fhir_version_cache_refresh(server_name=server_name, fhir_version=fhir_version)
        
        # Convert response to dict if it has to_dict method
        if hasattr(response, 'to_dict'):
            result = response.to_dict()
        elif isinstance(response, list) and response and hasattr(response[0], 'to_dict'):
            result = [item.to_dict() for item in response]
        else:
            result = response
        
        await ctx.info(f"create_proxy_backend_by_server_name_by_fhir_version_refresh completed successfully")
        return {"result": result}
        
    except ApiException as e:
        error_msg = _format_api_error(e)
        await ctx.error(f"Failed to execute create_proxy_backend_by_server_name_by_fhir_version_refresh: {error_msg}")
        return {"error": error_msg, "status": e.status}
    except Exception as e:
        await ctx.error(f"Unexpected error in create_proxy_backend_by_server_name_by_fhir_version_refresh: {str(e)}")
        return {"error": str(e)}

@mcp.tool()
async def update_proxy_smart_backend_by_server_name_by_fhir_version(ctx: Context, server_name: str, fhir_version: str) -> dict[str, Any]:
    """
    FHIR Resource Proxy
    
    Parameters:
        server_name: Parameter: server_name
        fhir_version: Parameter: fhir_version
    
    Auto-generated from: fhir_api.put_proxy_smart_backend_by_server_name_by_fhir_version()
    """
    try:
        await ctx.info(f"Calling update_proxy_smart_backend_by_server_name_by_fhir_version...")
        
        response = fhir_api.put_proxy_smart_backend_by_server_name_by_fhir_version(server_name=server_name, fhir_version=fhir_version)
        
        # Convert response to dict if it has to_dict method
        if hasattr(response, 'to_dict'):
            result = response.to_dict()
        elif isinstance(response, list) and response and hasattr(response[0], 'to_dict'):
            result = [item.to_dict() for item in response]
        else:
            result = response
        
        await ctx.info(f"update_proxy_smart_backend_by_server_name_by_fhir_version completed successfully")
        return {"result": result}
        
    except ApiException as e:
        error_msg = _format_api_error(e)
        await ctx.error(f"Failed to execute update_proxy_smart_backend_by_server_name_by_fhir_version: {error_msg}")
        return {"error": error_msg, "status": e.status}
    except Exception as e:
        await ctx.error(f"Unexpected error in update_proxy_smart_backend_by_server_name_by_fhir_version: {str(e)}")
        return {"error": str(e)}


# HealthcareUsersApi tools
# ======================================================================

@mcp.tool()
async def delete_admin_healthcare_users_by_user_id(ctx: Context, user_id: str) -> dict[str, Any]:
    """
    Delete Healthcare User
    
    Parameters:
        user_id: Parameter: user_id
    
    Auto-generated from: healthcare_users_api.delete_admin_healthcare_users_by_user_id()
    """
    try:
        await ctx.info(f"Calling delete_admin_healthcare_users_by_user_id...")
        
        response = healthcare_users_api.delete_admin_healthcare_users_by_user_id(user_id=user_id)
        
        # Convert response to dict if it has to_dict method
        if hasattr(response, 'to_dict'):
            result = response.to_dict()
        elif isinstance(response, list) and response and hasattr(response[0], 'to_dict'):
            result = [item.to_dict() for item in response]
        else:
            result = response
        
        await ctx.info(f"delete_admin_healthcare_users_by_user_id completed successfully")
        return {"result": result}
        
    except ApiException as e:
        error_msg = _format_api_error(e)
        await ctx.error(f"Failed to execute delete_admin_healthcare_users_by_user_id: {error_msg}")
        return {"error": error_msg, "status": e.status}
    except Exception as e:
        await ctx.error(f"Unexpected error in delete_admin_healthcare_users_by_user_id: {str(e)}")
        return {"error": str(e)}

@mcp.tool()
async def list_admin_healthcare_users(ctx: Context, limit: str | None = None, offset: str | None = None) -> dict[str, Any]:
    """
    List Healthcare Users
    
    Parameters:
        limit: Parameter: limit
        offset: Parameter: offset
    
    Auto-generated from: healthcare_users_api.get_admin_healthcare_users()
    """
    try:
        await ctx.info(f"Calling list_admin_healthcare_users...")
        
        response = healthcare_users_api.get_admin_healthcare_users(limit=limit, offset=offset)
        
        # Convert response to dict if it has to_dict method
        if hasattr(response, 'to_dict'):
            result = response.to_dict()
        elif isinstance(response, list) and response and hasattr(response[0], 'to_dict'):
            result = [item.to_dict() for item in response]
        else:
            result = response
        
        await ctx.info(f"list_admin_healthcare_users completed successfully")
        return {"result": result}
        
    except ApiException as e:
        error_msg = _format_api_error(e)
        await ctx.error(f"Failed to execute list_admin_healthcare_users: {error_msg}")
        return {"error": error_msg, "status": e.status}
    except Exception as e:
        await ctx.error(f"Unexpected error in list_admin_healthcare_users: {str(e)}")
        return {"error": str(e)}

@mcp.tool()
async def get_admin_healthcare_users_by_user_id(ctx: Context, user_id: str) -> dict[str, Any]:
    """
    Get Healthcare User
    
    Parameters:
        user_id: Parameter: user_id
    
    Auto-generated from: healthcare_users_api.get_admin_healthcare_users_by_user_id()
    """
    try:
        await ctx.info(f"Calling get_admin_healthcare_users_by_user_id...")
        
        response = healthcare_users_api.get_admin_healthcare_users_by_user_id(user_id=user_id)
        
        # Convert response to dict if it has to_dict method
        if hasattr(response, 'to_dict'):
            result = response.to_dict()
        elif isinstance(response, list) and response and hasattr(response[0], 'to_dict'):
            result = [item.to_dict() for item in response]
        else:
            result = response
        
        await ctx.info(f"get_admin_healthcare_users_by_user_id completed successfully")
        return {"result": result}
        
    except ApiException as e:
        error_msg = _format_api_error(e)
        await ctx.error(f"Failed to execute get_admin_healthcare_users_by_user_id: {error_msg}")
        return {"error": error_msg, "status": e.status}
    except Exception as e:
        await ctx.error(f"Unexpected error in get_admin_healthcare_users_by_user_id: {str(e)}")
        return {"error": str(e)}

@mcp.tool()
async def create_admin_healthcare_users(ctx: Context, create_healthcare_user_request: str) -> dict[str, Any]:
    """
    Create Healthcare User
    
    Parameters:
        create_healthcare_user_request: JSON object with the following fields:
  - username (REQUIRED): Username (must be unique)
  - email (REQUIRED): Email address
  - firstName (REQUIRED): First name
  - lastName (REQUIRED): Last name
  - organization (optional): Organization identifier
  - fhirUser (optional): FHIR user reference
  - password (optional): User password
  - temporaryPassword (optional): Whether password is temporary and must be changed
  - realmRoles (optional): Realm-level roles to assign
  - clientRoles (optional)
  - additional_properties (optional)
    
    Example JSON for parameters:
      create_healthcare_user_request:
        {
          "username": "Example Name",
          "email": "user@example.com",
          "firstName": "Example Name",
          "lastName": "Example Name"
        }
    
    Auto-generated from: healthcare_users_api.post_admin_healthcare_users()
    """
    try:
        await ctx.info(f"Calling create_admin_healthcare_users...")
        from api_client.models import CreateHealthcareUserRequest
        # Convert JSON string to Pydantic model
        import json
        create_healthcare_user_request_data = json.loads(create_healthcare_user_request) if isinstance(create_healthcare_user_request, str) else create_healthcare_user_request
        create_healthcare_user_request_obj = CreateHealthcareUserRequest(**create_healthcare_user_request_data)

        
        response = healthcare_users_api.post_admin_healthcare_users(create_healthcare_user_request=create_healthcare_user_request_obj)
        
        # Convert response to dict if it has to_dict method
        if hasattr(response, 'to_dict'):
            result = response.to_dict()
        elif isinstance(response, list) and response and hasattr(response[0], 'to_dict'):
            result = [item.to_dict() for item in response]
        else:
            result = response
        
        await ctx.info(f"create_admin_healthcare_users completed successfully")
        return {"result": result}
        
    except ApiException as e:
        error_msg = _format_api_error(e)
        await ctx.error(f"Failed to execute create_admin_healthcare_users: {error_msg}")
        return {"error": error_msg, "status": e.status}
    except Exception as e:
        await ctx.error(f"Unexpected error in create_admin_healthcare_users: {str(e)}")
        return {"error": str(e)}

@mcp.tool()
async def update_admin_healthcare_users_by_user_id(ctx: Context, user_id: str, update_healthcare_user_request: str) -> dict[str, Any]:
    """
    Update Healthcare User
    
    Parameters:
        user_id: Parameter: user_id
        update_healthcare_user_request: JSON object with the following fields:
  - firstName (optional): First name
  - lastName (optional): Last name
  - email (optional): Email address
  - enabled (optional): Whether the user is enabled
  - organization (optional): Organization identifier
  - fhirUser (optional): FHIR user reference
  - realmRoles (optional): Realm-level roles
  - clientRoles (optional)
  - additional_properties (optional)
    
    Example JSON for parameters:
      update_healthcare_user_request:
        {}
    
    Auto-generated from: healthcare_users_api.put_admin_healthcare_users_by_user_id()
    """
    try:
        await ctx.info(f"Calling update_admin_healthcare_users_by_user_id...")
        from api_client.models import UpdateHealthcareUserRequest
        # Convert JSON string to Pydantic model
        import json
        update_healthcare_user_request_data = json.loads(update_healthcare_user_request) if isinstance(update_healthcare_user_request, str) else update_healthcare_user_request
        update_healthcare_user_request_obj = UpdateHealthcareUserRequest(**update_healthcare_user_request_data)

        
        response = healthcare_users_api.put_admin_healthcare_users_by_user_id(user_id=user_id, update_healthcare_user_request=update_healthcare_user_request_obj)
        
        # Convert response to dict if it has to_dict method
        if hasattr(response, 'to_dict'):
            result = response.to_dict()
        elif isinstance(response, list) and response and hasattr(response[0], 'to_dict'):
            result = [item.to_dict() for item in response]
        else:
            result = response
        
        await ctx.info(f"update_admin_healthcare_users_by_user_id completed successfully")
        return {"result": result}
        
    except ApiException as e:
        error_msg = _format_api_error(e)
        await ctx.error(f"Failed to execute update_admin_healthcare_users_by_user_id: {error_msg}")
        return {"error": error_msg, "status": e.status}
    except Exception as e:
        await ctx.error(f"Unexpected error in update_admin_healthcare_users_by_user_id: {str(e)}")
        return {"error": str(e)}


# IdentityProvidersApi tools
# ======================================================================

@mcp.tool()
async def delete_admin_idps_by_alias(ctx: Context, alias: str) -> dict[str, Any]:
    """
    Delete Identity Provider
    
    Parameters:
        alias: Parameter: alias
    
    Auto-generated from: identity_providers_api.delete_admin_idps_by_alias()
    """
    try:
        await ctx.info(f"Calling delete_admin_idps_by_alias...")
        
        response = identity_providers_api.delete_admin_idps_by_alias(alias=alias)
        
        # Convert response to dict if it has to_dict method
        if hasattr(response, 'to_dict'):
            result = response.to_dict()
        elif isinstance(response, list) and response and hasattr(response[0], 'to_dict'):
            result = [item.to_dict() for item in response]
        else:
            result = response
        
        await ctx.info(f"delete_admin_idps_by_alias completed successfully")
        return {"result": result}
        
    except ApiException as e:
        error_msg = _format_api_error(e)
        await ctx.error(f"Failed to execute delete_admin_idps_by_alias: {error_msg}")
        return {"error": error_msg, "status": e.status}
    except Exception as e:
        await ctx.error(f"Unexpected error in delete_admin_idps_by_alias: {str(e)}")
        return {"error": str(e)}

@mcp.tool()
async def list_admin_idps(ctx: Context) -> dict[str, Any]:
    """
    List Identity Providers
    
    Auto-generated from: identity_providers_api.get_admin_idps()
    """
    try:
        await ctx.info(f"Calling list_admin_idps...")
        
        response = identity_providers_api.get_admin_idps()
        
        # Convert response to dict if it has to_dict method
        if hasattr(response, 'to_dict'):
            result = response.to_dict()
        elif isinstance(response, list) and response and hasattr(response[0], 'to_dict'):
            result = [item.to_dict() for item in response]
        else:
            result = response
        
        await ctx.info(f"list_admin_idps completed successfully")
        return {"result": result}
        
    except ApiException as e:
        error_msg = _format_api_error(e)
        await ctx.error(f"Failed to execute list_admin_idps: {error_msg}")
        return {"error": error_msg, "status": e.status}
    except Exception as e:
        await ctx.error(f"Unexpected error in list_admin_idps: {str(e)}")
        return {"error": str(e)}

@mcp.tool()
async def get_admin_idps_by_alias(ctx: Context, alias: str) -> dict[str, Any]:
    """
    Get Identity Provider
    
    Parameters:
        alias: Parameter: alias
    
    Auto-generated from: identity_providers_api.get_admin_idps_by_alias()
    """
    try:
        await ctx.info(f"Calling get_admin_idps_by_alias...")
        
        response = identity_providers_api.get_admin_idps_by_alias(alias=alias)
        
        # Convert response to dict if it has to_dict method
        if hasattr(response, 'to_dict'):
            result = response.to_dict()
        elif isinstance(response, list) and response and hasattr(response[0], 'to_dict'):
            result = [item.to_dict() for item in response]
        else:
            result = response
        
        await ctx.info(f"get_admin_idps_by_alias completed successfully")
        return {"result": result}
        
    except ApiException as e:
        error_msg = _format_api_error(e)
        await ctx.error(f"Failed to execute get_admin_idps_by_alias: {error_msg}")
        return {"error": error_msg, "status": e.status}
    except Exception as e:
        await ctx.error(f"Unexpected error in get_admin_idps_by_alias: {str(e)}")
        return {"error": str(e)}

@mcp.tool()
async def list_admin_idps_count(ctx: Context) -> dict[str, Any]:
    """
    Get Identity Providers Count
    
    Auto-generated from: identity_providers_api.get_admin_idps_count()
    """
    try:
        await ctx.info(f"Calling list_admin_idps_count...")
        
        response = identity_providers_api.get_admin_idps_count()
        
        # Convert response to dict if it has to_dict method
        if hasattr(response, 'to_dict'):
            result = response.to_dict()
        elif isinstance(response, list) and response and hasattr(response[0], 'to_dict'):
            result = [item.to_dict() for item in response]
        else:
            result = response
        
        await ctx.info(f"list_admin_idps_count completed successfully")
        return {"result": result}
        
    except ApiException as e:
        error_msg = _format_api_error(e)
        await ctx.error(f"Failed to execute list_admin_idps_count: {error_msg}")
        return {"error": error_msg, "status": e.status}
    except Exception as e:
        await ctx.error(f"Unexpected error in list_admin_idps_count: {str(e)}")
        return {"error": str(e)}

@mcp.tool()
async def create_admin_idps(ctx: Context, create_identity_provider_request: str) -> dict[str, Any]:
    """
    Create Identity Provider
    
    Parameters:
        create_identity_provider_request: JSON object with the following fields:
  - alias (REQUIRED): Provider alias (unique identifier)
  - providerId (REQUIRED): Provider type (oidc, saml, etc.)
  - config (REQUIRED)
  - displayName (optional): Display name for UI
  - enabled (optional): Whether to enable the provider
  - additional_properties (optional)
    
    Example JSON for parameters:
      create_identity_provider_request:
        {
          "alias": "<alias>",
          "providerId": "<provider_id>"
        }
    
    Auto-generated from: identity_providers_api.post_admin_idps()
    """
    try:
        await ctx.info(f"Calling create_admin_idps...")
        from api_client.models import CreateIdentityProviderRequest
        # Convert JSON string to Pydantic model
        import json
        create_identity_provider_request_data = json.loads(create_identity_provider_request) if isinstance(create_identity_provider_request, str) else create_identity_provider_request
        create_identity_provider_request_obj = CreateIdentityProviderRequest(**create_identity_provider_request_data)

        
        response = identity_providers_api.post_admin_idps(create_identity_provider_request=create_identity_provider_request_obj)
        
        # Convert response to dict if it has to_dict method
        if hasattr(response, 'to_dict'):
            result = response.to_dict()
        elif isinstance(response, list) and response and hasattr(response[0], 'to_dict'):
            result = [item.to_dict() for item in response]
        else:
            result = response
        
        await ctx.info(f"create_admin_idps completed successfully")
        return {"result": result}
        
    except ApiException as e:
        error_msg = _format_api_error(e)
        await ctx.error(f"Failed to execute create_admin_idps: {error_msg}")
        return {"error": error_msg, "status": e.status}
    except Exception as e:
        await ctx.error(f"Unexpected error in create_admin_idps: {str(e)}")
        return {"error": str(e)}

@mcp.tool()
async def update_admin_idps_by_alias(ctx: Context, alias: str, update_identity_provider_request: str) -> dict[str, Any]:
    """
    Update Identity Provider
    
    Parameters:
        alias: Parameter: alias
        update_identity_provider_request: JSON object with the following fields:
  - displayName (optional): Display name
  - enabled (optional): Enable or disable the provider
  - config (optional)
  - additional_properties (optional)
    
    Example JSON for parameters:
      update_identity_provider_request:
        {}
    
    Auto-generated from: identity_providers_api.put_admin_idps_by_alias()
    """
    try:
        await ctx.info(f"Calling update_admin_idps_by_alias...")
        from api_client.models import UpdateIdentityProviderRequest
        # Convert JSON string to Pydantic model
        import json
        update_identity_provider_request_data = json.loads(update_identity_provider_request) if isinstance(update_identity_provider_request, str) else update_identity_provider_request
        update_identity_provider_request_obj = UpdateIdentityProviderRequest(**update_identity_provider_request_data)

        
        response = identity_providers_api.put_admin_idps_by_alias(alias=alias, update_identity_provider_request=update_identity_provider_request_obj)
        
        # Convert response to dict if it has to_dict method
        if hasattr(response, 'to_dict'):
            result = response.to_dict()
        elif isinstance(response, list) and response and hasattr(response[0], 'to_dict'):
            result = [item.to_dict() for item in response]
        else:
            result = response
        
        await ctx.info(f"update_admin_idps_by_alias completed successfully")
        return {"result": result}
        
    except ApiException as e:
        error_msg = _format_api_error(e)
        await ctx.error(f"Failed to execute update_admin_idps_by_alias: {error_msg}")
        return {"error": error_msg, "status": e.status}
    except Exception as e:
        await ctx.error(f"Unexpected error in update_admin_idps_by_alias: {str(e)}")
        return {"error": str(e)}


# LaunchContextsApi tools
# ======================================================================

@mcp.tool()
async def delete_admin_launch_contexts_by_user_id_encounter(ctx: Context, user_id: str) -> dict[str, Any]:
    """
    Remove Encounter Context
    
    Parameters:
        user_id: Parameter: user_id
    
    Auto-generated from: launch_contexts_api.delete_admin_launch_contexts_by_user_id_encounter()
    """
    try:
        await ctx.info(f"Calling delete_admin_launch_contexts_by_user_id_encounter...")
        
        response = launch_contexts_api.delete_admin_launch_contexts_by_user_id_encounter(user_id=user_id)
        
        # Convert response to dict if it has to_dict method
        if hasattr(response, 'to_dict'):
            result = response.to_dict()
        elif isinstance(response, list) and response and hasattr(response[0], 'to_dict'):
            result = [item.to_dict() for item in response]
        else:
            result = response
        
        await ctx.info(f"delete_admin_launch_contexts_by_user_id_encounter completed successfully")
        return {"result": result}
        
    except ApiException as e:
        error_msg = _format_api_error(e)
        await ctx.error(f"Failed to execute delete_admin_launch_contexts_by_user_id_encounter: {error_msg}")
        return {"error": error_msg, "status": e.status}
    except Exception as e:
        await ctx.error(f"Unexpected error in delete_admin_launch_contexts_by_user_id_encounter: {str(e)}")
        return {"error": str(e)}

@mcp.tool()
async def delete_admin_launch_contexts_by_user_id_fhir_context(ctx: Context, user_id: str) -> dict[str, Any]:
    """
    Remove FHIR Context
    
    Parameters:
        user_id: Parameter: user_id
    
    Auto-generated from: launch_contexts_api.delete_admin_launch_contexts_by_user_id_fhir_context()
    """
    try:
        await ctx.info(f"Calling delete_admin_launch_contexts_by_user_id_fhir_context...")
        
        response = launch_contexts_api.delete_admin_launch_contexts_by_user_id_fhir_context(user_id=user_id)
        
        # Convert response to dict if it has to_dict method
        if hasattr(response, 'to_dict'):
            result = response.to_dict()
        elif isinstance(response, list) and response and hasattr(response[0], 'to_dict'):
            result = [item.to_dict() for item in response]
        else:
            result = response
        
        await ctx.info(f"delete_admin_launch_contexts_by_user_id_fhir_context completed successfully")
        return {"result": result}
        
    except ApiException as e:
        error_msg = _format_api_error(e)
        await ctx.error(f"Failed to execute delete_admin_launch_contexts_by_user_id_fhir_context: {error_msg}")
        return {"error": error_msg, "status": e.status}
    except Exception as e:
        await ctx.error(f"Unexpected error in delete_admin_launch_contexts_by_user_id_fhir_context: {str(e)}")
        return {"error": str(e)}

@mcp.tool()
async def delete_admin_launch_contexts_by_user_id_fhir_user(ctx: Context, user_id: str) -> dict[str, Any]:
    """
    Remove FHIR User Context
    
    Parameters:
        user_id: Parameter: user_id
    
    Auto-generated from: launch_contexts_api.delete_admin_launch_contexts_by_user_id_fhir_user()
    """
    try:
        await ctx.info(f"Calling delete_admin_launch_contexts_by_user_id_fhir_user...")
        
        response = launch_contexts_api.delete_admin_launch_contexts_by_user_id_fhir_user(user_id=user_id)
        
        # Convert response to dict if it has to_dict method
        if hasattr(response, 'to_dict'):
            result = response.to_dict()
        elif isinstance(response, list) and response and hasattr(response[0], 'to_dict'):
            result = [item.to_dict() for item in response]
        else:
            result = response
        
        await ctx.info(f"delete_admin_launch_contexts_by_user_id_fhir_user completed successfully")
        return {"result": result}
        
    except ApiException as e:
        error_msg = _format_api_error(e)
        await ctx.error(f"Failed to execute delete_admin_launch_contexts_by_user_id_fhir_user: {error_msg}")
        return {"error": error_msg, "status": e.status}
    except Exception as e:
        await ctx.error(f"Unexpected error in delete_admin_launch_contexts_by_user_id_fhir_user: {str(e)}")
        return {"error": str(e)}

@mcp.tool()
async def delete_admin_launch_contexts_by_user_id_intent(ctx: Context, user_id: str) -> dict[str, Any]:
    """
    Remove Intent Context
    
    Parameters:
        user_id: Parameter: user_id
    
    Auto-generated from: launch_contexts_api.delete_admin_launch_contexts_by_user_id_intent()
    """
    try:
        await ctx.info(f"Calling delete_admin_launch_contexts_by_user_id_intent...")
        
        response = launch_contexts_api.delete_admin_launch_contexts_by_user_id_intent(user_id=user_id)
        
        # Convert response to dict if it has to_dict method
        if hasattr(response, 'to_dict'):
            result = response.to_dict()
        elif isinstance(response, list) and response and hasattr(response[0], 'to_dict'):
            result = [item.to_dict() for item in response]
        else:
            result = response
        
        await ctx.info(f"delete_admin_launch_contexts_by_user_id_intent completed successfully")
        return {"result": result}
        
    except ApiException as e:
        error_msg = _format_api_error(e)
        await ctx.error(f"Failed to execute delete_admin_launch_contexts_by_user_id_intent: {error_msg}")
        return {"error": error_msg, "status": e.status}
    except Exception as e:
        await ctx.error(f"Unexpected error in delete_admin_launch_contexts_by_user_id_intent: {str(e)}")
        return {"error": str(e)}

@mcp.tool()
async def delete_admin_launch_contexts_by_user_id_need_patient_banner(ctx: Context, user_id: str) -> dict[str, Any]:
    """
    Remove Need Patient Banner Context
    
    Parameters:
        user_id: Parameter: user_id
    
    Auto-generated from: launch_contexts_api.delete_admin_launch_contexts_by_user_id_need_patient_banner()
    """
    try:
        await ctx.info(f"Calling delete_admin_launch_contexts_by_user_id_need_patient_banner...")
        
        response = launch_contexts_api.delete_admin_launch_contexts_by_user_id_need_patient_banner(user_id=user_id)
        
        # Convert response to dict if it has to_dict method
        if hasattr(response, 'to_dict'):
            result = response.to_dict()
        elif isinstance(response, list) and response and hasattr(response[0], 'to_dict'):
            result = [item.to_dict() for item in response]
        else:
            result = response
        
        await ctx.info(f"delete_admin_launch_contexts_by_user_id_need_patient_banner completed successfully")
        return {"result": result}
        
    except ApiException as e:
        error_msg = _format_api_error(e)
        await ctx.error(f"Failed to execute delete_admin_launch_contexts_by_user_id_need_patient_banner: {error_msg}")
        return {"error": error_msg, "status": e.status}
    except Exception as e:
        await ctx.error(f"Unexpected error in delete_admin_launch_contexts_by_user_id_need_patient_banner: {str(e)}")
        return {"error": str(e)}

@mcp.tool()
async def delete_admin_launch_contexts_by_user_id_patient(ctx: Context, user_id: str) -> dict[str, Any]:
    """
    Remove Patient Context
    
    Parameters:
        user_id: Parameter: user_id
    
    Auto-generated from: launch_contexts_api.delete_admin_launch_contexts_by_user_id_patient()
    """
    try:
        await ctx.info(f"Calling delete_admin_launch_contexts_by_user_id_patient...")
        
        response = launch_contexts_api.delete_admin_launch_contexts_by_user_id_patient(user_id=user_id)
        
        # Convert response to dict if it has to_dict method
        if hasattr(response, 'to_dict'):
            result = response.to_dict()
        elif isinstance(response, list) and response and hasattr(response[0], 'to_dict'):
            result = [item.to_dict() for item in response]
        else:
            result = response
        
        await ctx.info(f"delete_admin_launch_contexts_by_user_id_patient completed successfully")
        return {"result": result}
        
    except ApiException as e:
        error_msg = _format_api_error(e)
        await ctx.error(f"Failed to execute delete_admin_launch_contexts_by_user_id_patient: {error_msg}")
        return {"error": error_msg, "status": e.status}
    except Exception as e:
        await ctx.error(f"Unexpected error in delete_admin_launch_contexts_by_user_id_patient: {str(e)}")
        return {"error": str(e)}

@mcp.tool()
async def delete_admin_launch_contexts_by_user_id_smart_style_url(ctx: Context, user_id: str) -> dict[str, Any]:
    """
    Remove Smart Style URL Context
    
    Parameters:
        user_id: Parameter: user_id
    
    Auto-generated from: launch_contexts_api.delete_admin_launch_contexts_by_user_id_smart_style_url()
    """
    try:
        await ctx.info(f"Calling delete_admin_launch_contexts_by_user_id_smart_style_url...")
        
        response = launch_contexts_api.delete_admin_launch_contexts_by_user_id_smart_style_url(user_id=user_id)
        
        # Convert response to dict if it has to_dict method
        if hasattr(response, 'to_dict'):
            result = response.to_dict()
        elif isinstance(response, list) and response and hasattr(response[0], 'to_dict'):
            result = [item.to_dict() for item in response]
        else:
            result = response
        
        await ctx.info(f"delete_admin_launch_contexts_by_user_id_smart_style_url completed successfully")
        return {"result": result}
        
    except ApiException as e:
        error_msg = _format_api_error(e)
        await ctx.error(f"Failed to execute delete_admin_launch_contexts_by_user_id_smart_style_url: {error_msg}")
        return {"error": error_msg, "status": e.status}
    except Exception as e:
        await ctx.error(f"Unexpected error in delete_admin_launch_contexts_by_user_id_smart_style_url: {str(e)}")
        return {"error": str(e)}

@mcp.tool()
async def delete_admin_launch_contexts_by_user_id_tenant(ctx: Context, user_id: str) -> dict[str, Any]:
    """
    Remove Tenant Context
    
    Parameters:
        user_id: Parameter: user_id
    
    Auto-generated from: launch_contexts_api.delete_admin_launch_contexts_by_user_id_tenant()
    """
    try:
        await ctx.info(f"Calling delete_admin_launch_contexts_by_user_id_tenant...")
        
        response = launch_contexts_api.delete_admin_launch_contexts_by_user_id_tenant(user_id=user_id)
        
        # Convert response to dict if it has to_dict method
        if hasattr(response, 'to_dict'):
            result = response.to_dict()
        elif isinstance(response, list) and response and hasattr(response[0], 'to_dict'):
            result = [item.to_dict() for item in response]
        else:
            result = response
        
        await ctx.info(f"delete_admin_launch_contexts_by_user_id_tenant completed successfully")
        return {"result": result}
        
    except ApiException as e:
        error_msg = _format_api_error(e)
        await ctx.error(f"Failed to execute delete_admin_launch_contexts_by_user_id_tenant: {error_msg}")
        return {"error": error_msg, "status": e.status}
    except Exception as e:
        await ctx.error(f"Unexpected error in delete_admin_launch_contexts_by_user_id_tenant: {str(e)}")
        return {"error": str(e)}

@mcp.tool()
async def list_admin_launch_contexts(ctx: Context) -> dict[str, Any]:
    """
    List Launch Contexts
    
    Auto-generated from: launch_contexts_api.get_admin_launch_contexts()
    """
    try:
        await ctx.info(f"Calling list_admin_launch_contexts...")
        
        response = launch_contexts_api.get_admin_launch_contexts()
        
        # Convert response to dict if it has to_dict method
        if hasattr(response, 'to_dict'):
            result = response.to_dict()
        elif isinstance(response, list) and response and hasattr(response[0], 'to_dict'):
            result = [item.to_dict() for item in response]
        else:
            result = response
        
        await ctx.info(f"list_admin_launch_contexts completed successfully")
        return {"result": result}
        
    except ApiException as e:
        error_msg = _format_api_error(e)
        await ctx.error(f"Failed to execute list_admin_launch_contexts: {error_msg}")
        return {"error": error_msg, "status": e.status}
    except Exception as e:
        await ctx.error(f"Unexpected error in list_admin_launch_contexts: {str(e)}")
        return {"error": str(e)}

@mcp.tool()
async def create_lc_by_user_id_encounter_by_encounter_id(ctx: Context, user_id: str, encounter_id: str) -> dict[str, Any]:
    """
    Set Encounter Context
    
    Parameters:
        user_id: Parameter: user_id
        encounter_id: Parameter: encounter_id
    
    Auto-generated from: launch_contexts_api.post_admin_launch_contexts_by_user_id_encounter_by_encounter_id()
    """
    try:
        await ctx.info(f"Calling create_lc_by_user_id_encounter_by_encounter_id...")
        
        response = launch_contexts_api.post_admin_launch_contexts_by_user_id_encounter_by_encounter_id(user_id=user_id, encounter_id=encounter_id)
        
        # Convert response to dict if it has to_dict method
        if hasattr(response, 'to_dict'):
            result = response.to_dict()
        elif isinstance(response, list) and response and hasattr(response[0], 'to_dict'):
            result = [item.to_dict() for item in response]
        else:
            result = response
        
        await ctx.info(f"create_lc_by_user_id_encounter_by_encounter_id completed successfully")
        return {"result": result}
        
    except ApiException as e:
        error_msg = _format_api_error(e)
        await ctx.error(f"Failed to execute create_lc_by_user_id_encounter_by_encounter_id: {error_msg}")
        return {"error": error_msg, "status": e.status}
    except Exception as e:
        await ctx.error(f"Unexpected error in create_lc_by_user_id_encounter_by_encounter_id: {str(e)}")
        return {"error": str(e)}

@mcp.tool()
async def create_admin_launch_contexts_by_user_id_fhir_context(ctx: Context, user_id: str, set_fhir_context_request: str) -> dict[str, Any]:
    """
    Set FHIR Context
    
    Parameters:
        user_id: Parameter: user_id
        set_fhir_context_request: JSON object with the following fields:
  - fhirContext (REQUIRED): Additional FHIR resources in context (JSON array of objects)
  - additional_properties (optional)
    
    Example JSON for parameters:
      set_fhir_context_request:
        {
          "fhirContext": "<fhir_context>"
        }
    
    Auto-generated from: launch_contexts_api.post_admin_launch_contexts_by_user_id_fhir_context()
    """
    try:
        await ctx.info(f"Calling create_admin_launch_contexts_by_user_id_fhir_context...")
        from api_client.models import SetFhirContextRequest
        # Convert JSON string to Pydantic model
        import json
        set_fhir_context_request_data = json.loads(set_fhir_context_request) if isinstance(set_fhir_context_request, str) else set_fhir_context_request
        set_fhir_context_request_obj = SetFhirContextRequest(**set_fhir_context_request_data)

        
        response = launch_contexts_api.post_admin_launch_contexts_by_user_id_fhir_context(user_id=user_id, set_fhir_context_request=set_fhir_context_request_obj)
        
        # Convert response to dict if it has to_dict method
        if hasattr(response, 'to_dict'):
            result = response.to_dict()
        elif isinstance(response, list) and response and hasattr(response[0], 'to_dict'):
            result = [item.to_dict() for item in response]
        else:
            result = response
        
        await ctx.info(f"create_admin_launch_contexts_by_user_id_fhir_context completed successfully")
        return {"result": result}
        
    except ApiException as e:
        error_msg = _format_api_error(e)
        await ctx.error(f"Failed to execute create_admin_launch_contexts_by_user_id_fhir_context: {error_msg}")
        return {"error": error_msg, "status": e.status}
    except Exception as e:
        await ctx.error(f"Unexpected error in create_admin_launch_contexts_by_user_id_fhir_context: {str(e)}")
        return {"error": str(e)}

@mcp.tool()
async def create_lc_by_user_id_fhir_user_by_fhir_user_id(ctx: Context, user_id: str, fhir_user_id: str) -> dict[str, Any]:
    """
    Set FHIR User Context
    
    Parameters:
        user_id: Parameter: user_id
        fhir_user_id: Parameter: fhir_user_id
    
    Auto-generated from: launch_contexts_api.post_admin_launch_contexts_by_user_id_fhir_user_by_fhir_user_id()
    """
    try:
        await ctx.info(f"Calling create_lc_by_user_id_fhir_user_by_fhir_user_id...")
        
        response = launch_contexts_api.post_admin_launch_contexts_by_user_id_fhir_user_by_fhir_user_id(user_id=user_id, fhir_user_id=fhir_user_id)
        
        # Convert response to dict if it has to_dict method
        if hasattr(response, 'to_dict'):
            result = response.to_dict()
        elif isinstance(response, list) and response and hasattr(response[0], 'to_dict'):
            result = [item.to_dict() for item in response]
        else:
            result = response
        
        await ctx.info(f"create_lc_by_user_id_fhir_user_by_fhir_user_id completed successfully")
        return {"result": result}
        
    except ApiException as e:
        error_msg = _format_api_error(e)
        await ctx.error(f"Failed to execute create_lc_by_user_id_fhir_user_by_fhir_user_id: {error_msg}")
        return {"error": error_msg, "status": e.status}
    except Exception as e:
        await ctx.error(f"Unexpected error in create_lc_by_user_id_fhir_user_by_fhir_user_id: {str(e)}")
        return {"error": str(e)}

@mcp.tool()
async def create_admin_launch_contexts_by_user_id_patient_by_patient_id(ctx: Context, user_id: str, patient_id: str) -> dict[str, Any]:
    """
    Set Patient Context
    
    Parameters:
        user_id: Parameter: user_id
        patient_id: Parameter: patient_id
    
    Auto-generated from: launch_contexts_api.post_admin_launch_contexts_by_user_id_patient_by_patient_id()
    """
    try:
        await ctx.info(f"Calling create_admin_launch_contexts_by_user_id_patient_by_patient_id...")
        
        response = launch_contexts_api.post_admin_launch_contexts_by_user_id_patient_by_patient_id(user_id=user_id, patient_id=patient_id)
        
        # Convert response to dict if it has to_dict method
        if hasattr(response, 'to_dict'):
            result = response.to_dict()
        elif isinstance(response, list) and response and hasattr(response[0], 'to_dict'):
            result = [item.to_dict() for item in response]
        else:
            result = response
        
        await ctx.info(f"create_admin_launch_contexts_by_user_id_patient_by_patient_id completed successfully")
        return {"result": result}
        
    except ApiException as e:
        error_msg = _format_api_error(e)
        await ctx.error(f"Failed to execute create_admin_launch_contexts_by_user_id_patient_by_patient_id: {error_msg}")
        return {"error": error_msg, "status": e.status}
    except Exception as e:
        await ctx.error(f"Unexpected error in create_admin_launch_contexts_by_user_id_patient_by_patient_id: {str(e)}")
        return {"error": str(e)}

@mcp.tool()
async def update_admin_launch_contexts_by_user_id_intent(ctx: Context, user_id: str, set_intent_request: str) -> dict[str, Any]:
    """
    Set Intent Context
    
    Parameters:
        user_id: Parameter: user_id
        set_intent_request: JSON object with the following fields:
  - intent (REQUIRED): Intent string (e.g., reconcile-medications)
  - additional_properties (optional)
    
    Example JSON for parameters:
      set_intent_request:
        {
          "intent": "<intent>"
        }
    
    Auto-generated from: launch_contexts_api.put_admin_launch_contexts_by_user_id_intent()
    """
    try:
        await ctx.info(f"Calling update_admin_launch_contexts_by_user_id_intent...")
        from api_client.models import SetIntentRequest
        # Convert JSON string to Pydantic model
        import json
        set_intent_request_data = json.loads(set_intent_request) if isinstance(set_intent_request, str) else set_intent_request
        set_intent_request_obj = SetIntentRequest(**set_intent_request_data)

        
        response = launch_contexts_api.put_admin_launch_contexts_by_user_id_intent(user_id=user_id, set_intent_request=set_intent_request_obj)
        
        # Convert response to dict if it has to_dict method
        if hasattr(response, 'to_dict'):
            result = response.to_dict()
        elif isinstance(response, list) and response and hasattr(response[0], 'to_dict'):
            result = [item.to_dict() for item in response]
        else:
            result = response
        
        await ctx.info(f"update_admin_launch_contexts_by_user_id_intent completed successfully")
        return {"result": result}
        
    except ApiException as e:
        error_msg = _format_api_error(e)
        await ctx.error(f"Failed to execute update_admin_launch_contexts_by_user_id_intent: {error_msg}")
        return {"error": error_msg, "status": e.status}
    except Exception as e:
        await ctx.error(f"Unexpected error in update_admin_launch_contexts_by_user_id_intent: {str(e)}")
        return {"error": str(e)}

@mcp.tool()
async def update_admin_launch_contexts_by_user_id_need_patient_banner(ctx: Context, user_id: str, set_need_patient_banner_request: str) -> dict[str, Any]:
    """
    Set Need Patient Banner Context
    
    Parameters:
        user_id: Parameter: user_id
        set_need_patient_banner_request: JSON object with the following fields:
  - needPatientBanner (REQUIRED): Whether patient banner is required
  - additional_properties (optional)
    
    Example JSON for parameters:
      set_need_patient_banner_request:
        {
          "needPatientBanner": false
        }
    
    Auto-generated from: launch_contexts_api.put_admin_launch_contexts_by_user_id_need_patient_banner()
    """
    try:
        await ctx.info(f"Calling update_admin_launch_contexts_by_user_id_need_patient_banner...")
        from api_client.models import SetNeedPatientBannerRequest
        # Convert JSON string to Pydantic model
        import json
        set_need_patient_banner_request_data = json.loads(set_need_patient_banner_request) if isinstance(set_need_patient_banner_request, str) else set_need_patient_banner_request
        set_need_patient_banner_request_obj = SetNeedPatientBannerRequest(**set_need_patient_banner_request_data)

        
        response = launch_contexts_api.put_admin_launch_contexts_by_user_id_need_patient_banner(user_id=user_id, set_need_patient_banner_request=set_need_patient_banner_request_obj)
        
        # Convert response to dict if it has to_dict method
        if hasattr(response, 'to_dict'):
            result = response.to_dict()
        elif isinstance(response, list) and response and hasattr(response[0], 'to_dict'):
            result = [item.to_dict() for item in response]
        else:
            result = response
        
        await ctx.info(f"update_admin_launch_contexts_by_user_id_need_patient_banner completed successfully")
        return {"result": result}
        
    except ApiException as e:
        error_msg = _format_api_error(e)
        await ctx.error(f"Failed to execute update_admin_launch_contexts_by_user_id_need_patient_banner: {error_msg}")
        return {"error": error_msg, "status": e.status}
    except Exception as e:
        await ctx.error(f"Unexpected error in update_admin_launch_contexts_by_user_id_need_patient_banner: {str(e)}")
        return {"error": str(e)}

@mcp.tool()
async def update_admin_launch_contexts_by_user_id_smart_style_url(ctx: Context, user_id: str, set_smart_style_url_request: str) -> dict[str, Any]:
    """
    Set Smart Style URL Context
    
    Parameters:
        user_id: Parameter: user_id
        set_smart_style_url_request: JSON object with the following fields:
  - styleUrl (REQUIRED): URL to CSS stylesheet for styling
  - additional_properties (optional)
    
    Example JSON for parameters:
      set_smart_style_url_request:
        {
          "styleUrl": "<style_url>"
        }
    
    Auto-generated from: launch_contexts_api.put_admin_launch_contexts_by_user_id_smart_style_url()
    """
    try:
        await ctx.info(f"Calling update_admin_launch_contexts_by_user_id_smart_style_url...")
        from api_client.models import SetSmartStyleUrlRequest
        # Convert JSON string to Pydantic model
        import json
        set_smart_style_url_request_data = json.loads(set_smart_style_url_request) if isinstance(set_smart_style_url_request, str) else set_smart_style_url_request
        set_smart_style_url_request_obj = SetSmartStyleUrlRequest(**set_smart_style_url_request_data)

        
        response = launch_contexts_api.put_admin_launch_contexts_by_user_id_smart_style_url(user_id=user_id, set_smart_style_url_request=set_smart_style_url_request_obj)
        
        # Convert response to dict if it has to_dict method
        if hasattr(response, 'to_dict'):
            result = response.to_dict()
        elif isinstance(response, list) and response and hasattr(response[0], 'to_dict'):
            result = [item.to_dict() for item in response]
        else:
            result = response
        
        await ctx.info(f"update_admin_launch_contexts_by_user_id_smart_style_url completed successfully")
        return {"result": result}
        
    except ApiException as e:
        error_msg = _format_api_error(e)
        await ctx.error(f"Failed to execute update_admin_launch_contexts_by_user_id_smart_style_url: {error_msg}")
        return {"error": error_msg, "status": e.status}
    except Exception as e:
        await ctx.error(f"Unexpected error in update_admin_launch_contexts_by_user_id_smart_style_url: {str(e)}")
        return {"error": str(e)}

@mcp.tool()
async def update_admin_launch_contexts_by_user_id_tenant(ctx: Context, user_id: str, set_tenant_request: str) -> dict[str, Any]:
    """
    Set Tenant Context
    
    Parameters:
        user_id: Parameter: user_id
        set_tenant_request: JSON object with the following fields:
  - tenant (REQUIRED): Tenant identifier
  - additional_properties (optional)
    
    Example JSON for parameters:
      set_tenant_request:
        {
          "tenant": "<tenant>"
        }
    
    Auto-generated from: launch_contexts_api.put_admin_launch_contexts_by_user_id_tenant()
    """
    try:
        await ctx.info(f"Calling update_admin_launch_contexts_by_user_id_tenant...")
        from api_client.models import SetTenantRequest
        # Convert JSON string to Pydantic model
        import json
        set_tenant_request_data = json.loads(set_tenant_request) if isinstance(set_tenant_request, str) else set_tenant_request
        set_tenant_request_obj = SetTenantRequest(**set_tenant_request_data)

        
        response = launch_contexts_api.put_admin_launch_contexts_by_user_id_tenant(user_id=user_id, set_tenant_request=set_tenant_request_obj)
        
        # Convert response to dict if it has to_dict method
        if hasattr(response, 'to_dict'):
            result = response.to_dict()
        elif isinstance(response, list) and response and hasattr(response[0], 'to_dict'):
            result = [item.to_dict() for item in response]
        else:
            result = response
        
        await ctx.info(f"update_admin_launch_contexts_by_user_id_tenant completed successfully")
        return {"result": result}
        
    except ApiException as e:
        error_msg = _format_api_error(e)
        await ctx.error(f"Failed to execute update_admin_launch_contexts_by_user_id_tenant: {error_msg}")
        return {"error": error_msg, "status": e.status}
    except Exception as e:
        await ctx.error(f"Unexpected error in update_admin_launch_contexts_by_user_id_tenant: {str(e)}")
        return {"error": str(e)}


# OauthMonitoringApi tools
# ======================================================================

@mcp.tool()
async def list_monitoring_oauth_analytics(ctx: Context, authorization: str | None = None) -> dict[str, Any]:
    """
    Get OAuth Analytics
    
    Parameters:
        authorization: Parameter: authorization
    
    Auto-generated from: oauth_monitoring_api.get_monitoring_oauth_analytics()
    """
    try:
        await ctx.info(f"Calling list_monitoring_oauth_analytics...")
        
        response = oauth_monitoring_api.get_monitoring_oauth_analytics(authorization=authorization)
        
        # Convert response to dict if it has to_dict method
        if hasattr(response, 'to_dict'):
            result = response.to_dict()
        elif isinstance(response, list) and response and hasattr(response[0], 'to_dict'):
            result = [item.to_dict() for item in response]
        else:
            result = response
        
        await ctx.info(f"list_monitoring_oauth_analytics completed successfully")
        return {"result": result}
        
    except ApiException as e:
        error_msg = _format_api_error(e)
        await ctx.error(f"Failed to execute list_monitoring_oauth_analytics: {error_msg}")
        return {"error": error_msg, "status": e.status}
    except Exception as e:
        await ctx.error(f"Unexpected error in list_monitoring_oauth_analytics: {str(e)}")
        return {"error": str(e)}

@mcp.tool()
async def list_monitoring_oauth_analytics_export(ctx: Context, authorization: str) -> dict[str, Any]:
    """
    Export Analytics Data
    
    Parameters:
        authorization: Parameter: authorization
    
    Auto-generated from: oauth_monitoring_api.get_monitoring_oauth_analytics_export()
    """
    try:
        await ctx.info(f"Calling list_monitoring_oauth_analytics_export...")
        
        response = oauth_monitoring_api.get_monitoring_oauth_analytics_export(authorization=authorization)
        
        # Convert response to dict if it has to_dict method
        if hasattr(response, 'to_dict'):
            result = response.to_dict()
        elif isinstance(response, list) and response and hasattr(response[0], 'to_dict'):
            result = [item.to_dict() for item in response]
        else:
            result = response
        
        await ctx.info(f"list_monitoring_oauth_analytics_export completed successfully")
        return {"result": result}
        
    except ApiException as e:
        error_msg = _format_api_error(e)
        await ctx.error(f"Failed to execute list_monitoring_oauth_analytics_export: {error_msg}")
        return {"error": error_msg, "status": e.status}
    except Exception as e:
        await ctx.error(f"Unexpected error in list_monitoring_oauth_analytics_export: {str(e)}")
        return {"error": str(e)}

@mcp.tool()
async def list_monitoring_oauth_analytics_stream(ctx: Context, token: str | None = None, authorization: str | None = None) -> dict[str, Any]:
    """
    OAuth Analytics Stream
    
    Parameters:
        token: Parameter: token
        authorization: Parameter: authorization
    
    Auto-generated from: oauth_monitoring_api.get_monitoring_oauth_analytics_stream()
    """
    try:
        await ctx.info(f"Calling list_monitoring_oauth_analytics_stream...")
        
        response = oauth_monitoring_api.get_monitoring_oauth_analytics_stream(token=token, authorization=authorization)
        
        # Convert response to dict if it has to_dict method
        if hasattr(response, 'to_dict'):
            result = response.to_dict()
        elif isinstance(response, list) and response and hasattr(response[0], 'to_dict'):
            result = [item.to_dict() for item in response]
        else:
            result = response
        
        await ctx.info(f"list_monitoring_oauth_analytics_stream completed successfully")
        return {"result": result}
        
    except ApiException as e:
        error_msg = _format_api_error(e)
        await ctx.error(f"Failed to execute list_monitoring_oauth_analytics_stream: {error_msg}")
        return {"error": error_msg, "status": e.status}
    except Exception as e:
        await ctx.error(f"Unexpected error in list_monitoring_oauth_analytics_stream: {str(e)}")
        return {"error": str(e)}

@mcp.tool()
async def list_monitoring_oauth_events(ctx: Context, limit: str | None = None, type: str | None = None, status: str | None = None, client_id: str | None = None, since: str | None = None, authorization: str | None = None) -> dict[str, Any]:
    """
    Get OAuth Events
    
    Parameters:
        limit: Parameter: limit
        type: Parameter: type
        status: Parameter: status
        client_id: Parameter: client_id
        since: Parameter: since
        authorization: Parameter: authorization
    
    Auto-generated from: oauth_monitoring_api.get_monitoring_oauth_events()
    """
    try:
        await ctx.info(f"Calling list_monitoring_oauth_events...")
        
        response = oauth_monitoring_api.get_monitoring_oauth_events(limit=limit, type=type, status=status, client_id=client_id, since=since, authorization=authorization)
        
        # Convert response to dict if it has to_dict method
        if hasattr(response, 'to_dict'):
            result = response.to_dict()
        elif isinstance(response, list) and response and hasattr(response[0], 'to_dict'):
            result = [item.to_dict() for item in response]
        else:
            result = response
        
        await ctx.info(f"list_monitoring_oauth_events completed successfully")
        return {"result": result}
        
    except ApiException as e:
        error_msg = _format_api_error(e)
        await ctx.error(f"Failed to execute list_monitoring_oauth_events: {error_msg}")
        return {"error": error_msg, "status": e.status}
    except Exception as e:
        await ctx.error(f"Unexpected error in list_monitoring_oauth_events: {str(e)}")
        return {"error": str(e)}

@mcp.tool()
async def list_monitoring_oauth_events_export(ctx: Context, authorization: str) -> dict[str, Any]:
    """
    Export Events Data
    
    Parameters:
        authorization: Parameter: authorization
    
    Auto-generated from: oauth_monitoring_api.get_monitoring_oauth_events_export()
    """
    try:
        await ctx.info(f"Calling list_monitoring_oauth_events_export...")
        
        response = oauth_monitoring_api.get_monitoring_oauth_events_export(authorization=authorization)
        
        # Convert response to dict if it has to_dict method
        if hasattr(response, 'to_dict'):
            result = response.to_dict()
        elif isinstance(response, list) and response and hasattr(response[0], 'to_dict'):
            result = [item.to_dict() for item in response]
        else:
            result = response
        
        await ctx.info(f"list_monitoring_oauth_events_export completed successfully")
        return {"result": result}
        
    except ApiException as e:
        error_msg = _format_api_error(e)
        await ctx.error(f"Failed to execute list_monitoring_oauth_events_export: {error_msg}")
        return {"error": error_msg, "status": e.status}
    except Exception as e:
        await ctx.error(f"Unexpected error in list_monitoring_oauth_events_export: {str(e)}")
        return {"error": str(e)}

@mcp.tool()
async def list_monitoring_oauth_events_stream(ctx: Context, token: str | None = None, authorization: str | None = None) -> dict[str, Any]:
    """
    OAuth Events Stream
    
    Parameters:
        token: Parameter: token
        authorization: Parameter: authorization
    
    Auto-generated from: oauth_monitoring_api.get_monitoring_oauth_events_stream()
    """
    try:
        await ctx.info(f"Calling list_monitoring_oauth_events_stream...")
        
        response = oauth_monitoring_api.get_monitoring_oauth_events_stream(token=token, authorization=authorization)
        
        # Convert response to dict if it has to_dict method
        if hasattr(response, 'to_dict'):
            result = response.to_dict()
        elif isinstance(response, list) and response and hasattr(response[0], 'to_dict'):
            result = [item.to_dict() for item in response]
        else:
            result = response
        
        await ctx.info(f"list_monitoring_oauth_events_stream completed successfully")
        return {"result": result}
        
    except ApiException as e:
        error_msg = _format_api_error(e)
        await ctx.error(f"Failed to execute list_monitoring_oauth_events_stream: {error_msg}")
        return {"error": error_msg, "status": e.status}
    except Exception as e:
        await ctx.error(f"Unexpected error in list_monitoring_oauth_events_stream: {str(e)}")
        return {"error": str(e)}

@mcp.tool()
async def list_monitoring_oauth_health(ctx: Context, authorization: str | None = None) -> dict[str, Any]:
    """
    Get System Health
    
    Parameters:
        authorization: Parameter: authorization
    
    Auto-generated from: oauth_monitoring_api.get_monitoring_oauth_health()
    """
    try:
        await ctx.info(f"Calling list_monitoring_oauth_health...")
        
        response = oauth_monitoring_api.get_monitoring_oauth_health(authorization=authorization)
        
        # Convert response to dict if it has to_dict method
        if hasattr(response, 'to_dict'):
            result = response.to_dict()
        elif isinstance(response, list) and response and hasattr(response[0], 'to_dict'):
            result = [item.to_dict() for item in response]
        else:
            result = response
        
        await ctx.info(f"list_monitoring_oauth_health completed successfully")
        return {"result": result}
        
    except ApiException as e:
        error_msg = _format_api_error(e)
        await ctx.error(f"Failed to execute list_monitoring_oauth_health: {error_msg}")
        return {"error": error_msg, "status": e.status}
    except Exception as e:
        await ctx.error(f"Unexpected error in list_monitoring_oauth_health: {str(e)}")
        return {"error": str(e)}

@mcp.tool()
async def list_oauth_monitoring_websocket_info(ctx: Context) -> dict[str, Any]:
    """
    WebSocket Connection Info
    
    Auto-generated from: oauth_monitoring_api.get_oauth_monitoring_websocket_info()
    """
    try:
        await ctx.info(f"Calling list_oauth_monitoring_websocket_info...")
        
        response = oauth_monitoring_api.get_oauth_monitoring_websocket_info()
        
        # Convert response to dict if it has to_dict method
        if hasattr(response, 'to_dict'):
            result = response.to_dict()
        elif isinstance(response, list) and response and hasattr(response[0], 'to_dict'):
            result = [item.to_dict() for item in response]
        else:
            result = response
        
        await ctx.info(f"list_oauth_monitoring_websocket_info completed successfully")
        return {"result": result}
        
    except ApiException as e:
        error_msg = _format_api_error(e)
        await ctx.error(f"Failed to execute list_oauth_monitoring_websocket_info: {error_msg}")
        return {"error": error_msg, "status": e.status}
    except Exception as e:
        await ctx.error(f"Unexpected error in list_oauth_monitoring_websocket_info: {str(e)}")
        return {"error": str(e)}


# RolesApi tools
# ======================================================================

@mcp.tool()
async def delete_admin_roles_by_role_name(ctx: Context, role_name: str) -> dict[str, Any]:
    """
    Delete Healthcare Role
    
    Parameters:
        role_name: Parameter: role_name
    
    Auto-generated from: roles_api.delete_admin_roles_by_role_name()
    """
    try:
        await ctx.info(f"Calling delete_admin_roles_by_role_name...")
        
        response = roles_api.delete_admin_roles_by_role_name(role_name=role_name)
        
        # Convert response to dict if it has to_dict method
        if hasattr(response, 'to_dict'):
            result = response.to_dict()
        elif isinstance(response, list) and response and hasattr(response[0], 'to_dict'):
            result = [item.to_dict() for item in response]
        else:
            result = response
        
        await ctx.info(f"delete_admin_roles_by_role_name completed successfully")
        return {"result": result}
        
    except ApiException as e:
        error_msg = _format_api_error(e)
        await ctx.error(f"Failed to execute delete_admin_roles_by_role_name: {error_msg}")
        return {"error": error_msg, "status": e.status}
    except Exception as e:
        await ctx.error(f"Unexpected error in delete_admin_roles_by_role_name: {str(e)}")
        return {"error": str(e)}

@mcp.tool()
async def list_admin_roles(ctx: Context) -> dict[str, Any]:
    """
    List All Roles
    
    Auto-generated from: roles_api.get_admin_roles()
    """
    try:
        await ctx.info(f"Calling list_admin_roles...")
        
        response = roles_api.get_admin_roles()
        
        # Convert response to dict if it has to_dict method
        if hasattr(response, 'to_dict'):
            result = response.to_dict()
        elif isinstance(response, list) and response and hasattr(response[0], 'to_dict'):
            result = [item.to_dict() for item in response]
        else:
            result = response
        
        await ctx.info(f"list_admin_roles completed successfully")
        return {"result": result}
        
    except ApiException as e:
        error_msg = _format_api_error(e)
        await ctx.error(f"Failed to execute list_admin_roles: {error_msg}")
        return {"error": error_msg, "status": e.status}
    except Exception as e:
        await ctx.error(f"Unexpected error in list_admin_roles: {str(e)}")
        return {"error": str(e)}

@mcp.tool()
async def get_admin_roles_by_role_name(ctx: Context, role_name: str) -> dict[str, Any]:
    """
    Get Healthcare Role
    
    Parameters:
        role_name: Parameter: role_name
    
    Auto-generated from: roles_api.get_admin_roles_by_role_name()
    """
    try:
        await ctx.info(f"Calling get_admin_roles_by_role_name...")
        
        response = roles_api.get_admin_roles_by_role_name(role_name=role_name)
        
        # Convert response to dict if it has to_dict method
        if hasattr(response, 'to_dict'):
            result = response.to_dict()
        elif isinstance(response, list) and response and hasattr(response[0], 'to_dict'):
            result = [item.to_dict() for item in response]
        else:
            result = response
        
        await ctx.info(f"get_admin_roles_by_role_name completed successfully")
        return {"result": result}
        
    except ApiException as e:
        error_msg = _format_api_error(e)
        await ctx.error(f"Failed to execute get_admin_roles_by_role_name: {error_msg}")
        return {"error": error_msg, "status": e.status}
    except Exception as e:
        await ctx.error(f"Unexpected error in get_admin_roles_by_role_name: {str(e)}")
        return {"error": str(e)}

@mcp.tool()
async def create_admin_roles(ctx: Context, create_role_request: str) -> dict[str, Any]:
    """
    Create Healthcare Role
    
    Parameters:
        create_role_request: JSON object with the following fields:
  - name (REQUIRED): Role name (must be unique)
  - description (optional): Role description
  - fhirScopes (optional): FHIR scopes associated with this role
  - additional_properties (optional)
    
    Example JSON for parameters:
      create_role_request:
        {
          "name": "Example Name"
        }
    
    Auto-generated from: roles_api.post_admin_roles()
    """
    try:
        await ctx.info(f"Calling create_admin_roles...")
        from api_client.models import CreateRoleRequest
        # Convert JSON string to Pydantic model
        import json
        create_role_request_data = json.loads(create_role_request) if isinstance(create_role_request, str) else create_role_request
        create_role_request_obj = CreateRoleRequest(**create_role_request_data)

        
        response = roles_api.post_admin_roles(create_role_request=create_role_request_obj)
        
        # Convert response to dict if it has to_dict method
        if hasattr(response, 'to_dict'):
            result = response.to_dict()
        elif isinstance(response, list) and response and hasattr(response[0], 'to_dict'):
            result = [item.to_dict() for item in response]
        else:
            result = response
        
        await ctx.info(f"create_admin_roles completed successfully")
        return {"result": result}
        
    except ApiException as e:
        error_msg = _format_api_error(e)
        await ctx.error(f"Failed to execute create_admin_roles: {error_msg}")
        return {"error": error_msg, "status": e.status}
    except Exception as e:
        await ctx.error(f"Unexpected error in create_admin_roles: {str(e)}")
        return {"error": str(e)}

@mcp.tool()
async def update_admin_roles_by_role_name(ctx: Context, role_name: str, update_role_request: str) -> dict[str, Any]:
    """
    Update Healthcare Role
    
    Parameters:
        role_name: Parameter: role_name
        update_role_request: JSON object with the following fields:
  - description (optional): Role description
  - fhirScopes (optional): FHIR scopes associated with this role
  - additional_properties (optional)
    
    Example JSON for parameters:
      update_role_request:
        {}
    
    Auto-generated from: roles_api.put_admin_roles_by_role_name()
    """
    try:
        await ctx.info(f"Calling update_admin_roles_by_role_name...")
        from api_client.models import UpdateRoleRequest
        # Convert JSON string to Pydantic model
        import json
        update_role_request_data = json.loads(update_role_request) if isinstance(update_role_request, str) else update_role_request
        update_role_request_obj = UpdateRoleRequest(**update_role_request_data)

        
        response = roles_api.put_admin_roles_by_role_name(role_name=role_name, update_role_request=update_role_request_obj)
        
        # Convert response to dict if it has to_dict method
        if hasattr(response, 'to_dict'):
            result = response.to_dict()
        elif isinstance(response, list) and response and hasattr(response[0], 'to_dict'):
            result = [item.to_dict() for item in response]
        else:
            result = response
        
        await ctx.info(f"update_admin_roles_by_role_name completed successfully")
        return {"result": result}
        
    except ApiException as e:
        error_msg = _format_api_error(e)
        await ctx.error(f"Failed to execute update_admin_roles_by_role_name: {error_msg}")
        return {"error": error_msg, "status": e.status}
    except Exception as e:
        await ctx.error(f"Unexpected error in update_admin_roles_by_role_name: {str(e)}")
        return {"error": str(e)}


# ServerApi tools
# ======================================================================

@mcp.tool()
async def list_health(ctx: Context, force: str | None = None) -> dict[str, Any]:
    """
    Health Check (lean)
    
    Parameters:
        force: Parameter: force
    
    Auto-generated from: server_api.get_health()
    """
    try:
        await ctx.info(f"Calling list_health...")
        
        response = server_api.get_health(force=force)
        
        # Convert response to dict if it has to_dict method
        if hasattr(response, 'to_dict'):
            result = response.to_dict()
        elif isinstance(response, list) and response and hasattr(response[0], 'to_dict'):
            result = [item.to_dict() for item in response]
        else:
            result = response
        
        await ctx.info(f"list_health completed successfully")
        return {"result": result}
        
    except ApiException as e:
        error_msg = _format_api_error(e)
        await ctx.error(f"Failed to execute list_health: {error_msg}")
        return {"error": error_msg, "status": e.status}
    except Exception as e:
        await ctx.error(f"Unexpected error in list_health: {str(e)}")
        return {"error": str(e)}

@mcp.tool()
async def list_status(ctx: Context) -> dict[str, Any]:
    """
    System Status
    
    Auto-generated from: server_api.get_status()
    """
    try:
        await ctx.info(f"Calling list_status...")
        
        response = server_api.get_status()
        
        # Convert response to dict if it has to_dict method
        if hasattr(response, 'to_dict'):
            result = response.to_dict()
        elif isinstance(response, list) and response and hasattr(response[0], 'to_dict'):
            result = [item.to_dict() for item in response]
        else:
            result = response
        
        await ctx.info(f"list_status completed successfully")
        return {"result": result}
        
    except ApiException as e:
        error_msg = _format_api_error(e)
        await ctx.error(f"Failed to execute list_status: {error_msg}")
        return {"error": error_msg, "status": e.status}
    except Exception as e:
        await ctx.error(f"Unexpected error in list_status: {str(e)}")
        return {"error": str(e)}


# ServersApi tools
# ======================================================================

@mcp.tool()
async def list_fhir_servers(ctx: Context) -> dict[str, Any]:
    """
    List Available FHIR Servers
    
    Auto-generated from: servers_api.get_fhir_servers()
    """
    try:
        await ctx.info(f"Calling list_fhir_servers...")
        
        response = servers_api.get_fhir_servers()
        
        # Convert response to dict if it has to_dict method
        if hasattr(response, 'to_dict'):
            result = response.to_dict()
        elif isinstance(response, list) and response and hasattr(response[0], 'to_dict'):
            result = [item.to_dict() for item in response]
        else:
            result = response
        
        await ctx.info(f"list_fhir_servers completed successfully")
        return {"result": result}
        
    except ApiException as e:
        error_msg = _format_api_error(e)
        await ctx.error(f"Failed to execute list_fhir_servers: {error_msg}")
        return {"error": error_msg, "status": e.status}
    except Exception as e:
        await ctx.error(f"Unexpected error in list_fhir_servers: {str(e)}")
        return {"error": str(e)}

@mcp.tool()
async def get_fhir_servers_by_server_id(ctx: Context, server_id: str) -> dict[str, Any]:
    """
    Get Server Information
    
    Parameters:
        server_id: Parameter: server_id
    
    Auto-generated from: servers_api.get_fhir_servers_by_server_id()
    """
    try:
        await ctx.info(f"Calling get_fhir_servers_by_server_id...")
        
        response = servers_api.get_fhir_servers_by_server_id(server_id=server_id)
        
        # Convert response to dict if it has to_dict method
        if hasattr(response, 'to_dict'):
            result = response.to_dict()
        elif isinstance(response, list) and response and hasattr(response[0], 'to_dict'):
            result = [item.to_dict() for item in response]
        else:
            result = response
        
        await ctx.info(f"get_fhir_servers_by_server_id completed successfully")
        return {"result": result}
        
    except ApiException as e:
        error_msg = _format_api_error(e)
        await ctx.error(f"Failed to execute get_fhir_servers_by_server_id: {error_msg}")
        return {"error": error_msg, "status": e.status}
    except Exception as e:
        await ctx.error(f"Unexpected error in get_fhir_servers_by_server_id: {str(e)}")
        return {"error": str(e)}

@mcp.tool()
async def get_fhir_servers_by_server_id_mtls(ctx: Context, server_id: str) -> dict[str, Any]:
    """
    Get mTLS Configuration
    
    Parameters:
        server_id: Parameter: server_id
    
    Auto-generated from: servers_api.get_fhir_servers_by_server_id_mtls()
    """
    try:
        await ctx.info(f"Calling get_fhir_servers_by_server_id_mtls...")
        
        response = servers_api.get_fhir_servers_by_server_id_mtls(server_id=server_id)
        
        # Convert response to dict if it has to_dict method
        if hasattr(response, 'to_dict'):
            result = response.to_dict()
        elif isinstance(response, list) and response and hasattr(response[0], 'to_dict'):
            result = [item.to_dict() for item in response]
        else:
            result = response
        
        await ctx.info(f"get_fhir_servers_by_server_id_mtls completed successfully")
        return {"result": result}
        
    except ApiException as e:
        error_msg = _format_api_error(e)
        await ctx.error(f"Failed to execute get_fhir_servers_by_server_id_mtls: {error_msg}")
        return {"error": error_msg, "status": e.status}
    except Exception as e:
        await ctx.error(f"Unexpected error in get_fhir_servers_by_server_id_mtls: {str(e)}")
        return {"error": str(e)}

@mcp.tool()
async def create_fhir_servers(ctx: Context, add_fhir_server_request: str) -> dict[str, Any]:
    """
    Add New FHIR Server
    
    Parameters:
        add_fhir_server_request: JSON object with the following fields:
  - url (REQUIRED): Base URL of the FHIR server to add
  - name (optional): Optional custom name for the server
  - additional_properties (optional)
    
    Example JSON for parameters:
      add_fhir_server_request:
        {
          "url": "<url>"
        }
    
    Auto-generated from: servers_api.post_fhir_servers()
    """
    try:
        await ctx.info(f"Calling create_fhir_servers...")
        from api_client.models import AddFhirServerRequest
        # Convert JSON string to Pydantic model
        import json
        add_fhir_server_request_data = json.loads(add_fhir_server_request) if isinstance(add_fhir_server_request, str) else add_fhir_server_request
        add_fhir_server_request_obj = AddFhirServerRequest(**add_fhir_server_request_data)

        
        response = servers_api.post_fhir_servers(add_fhir_server_request=add_fhir_server_request_obj)
        
        # Convert response to dict if it has to_dict method
        if hasattr(response, 'to_dict'):
            result = response.to_dict()
        elif isinstance(response, list) and response and hasattr(response[0], 'to_dict'):
            result = [item.to_dict() for item in response]
        else:
            result = response
        
        await ctx.info(f"create_fhir_servers completed successfully")
        return {"result": result}
        
    except ApiException as e:
        error_msg = _format_api_error(e)
        await ctx.error(f"Failed to execute create_fhir_servers: {error_msg}")
        return {"error": error_msg, "status": e.status}
    except Exception as e:
        await ctx.error(f"Unexpected error in create_fhir_servers: {str(e)}")
        return {"error": str(e)}

@mcp.tool()
async def create_fhir_servers_by_server_id_mtls_certificates(ctx: Context, server_id: str, upload_certificate_request: str) -> dict[str, Any]:
    """
    Upload Certificate
    
    Parameters:
        server_id: Parameter: server_id
        upload_certificate_request: JSON object with the following fields:
  - type (REQUIRED)
  - content (REQUIRED): Base64-encoded certificate or key content
  - filename (optional): Original filename (for reference)
  - additional_properties (optional)
    
    Example JSON for parameters:
      upload_certificate_request:
        {
          "type": "<type>",
          "content": "<content>"
        }
    
    Auto-generated from: servers_api.post_fhir_servers_by_server_id_mtls_certificates()
    """
    try:
        await ctx.info(f"Calling create_fhir_servers_by_server_id_mtls_certificates...")
        from api_client.models import UploadCertificateRequest
        # Convert JSON string to Pydantic model
        import json
        upload_certificate_request_data = json.loads(upload_certificate_request) if isinstance(upload_certificate_request, str) else upload_certificate_request
        upload_certificate_request_obj = UploadCertificateRequest(**upload_certificate_request_data)

        
        response = servers_api.post_fhir_servers_by_server_id_mtls_certificates(server_id=server_id, upload_certificate_request=upload_certificate_request_obj)
        
        # Convert response to dict if it has to_dict method
        if hasattr(response, 'to_dict'):
            result = response.to_dict()
        elif isinstance(response, list) and response and hasattr(response[0], 'to_dict'):
            result = [item.to_dict() for item in response]
        else:
            result = response
        
        await ctx.info(f"create_fhir_servers_by_server_id_mtls_certificates completed successfully")
        return {"result": result}
        
    except ApiException as e:
        error_msg = _format_api_error(e)
        await ctx.error(f"Failed to execute create_fhir_servers_by_server_id_mtls_certificates: {error_msg}")
        return {"error": error_msg, "status": e.status}
    except Exception as e:
        await ctx.error(f"Unexpected error in create_fhir_servers_by_server_id_mtls_certificates: {str(e)}")
        return {"error": str(e)}

@mcp.tool()
async def update_fhir_servers_by_server_id(ctx: Context, server_id: str, update_fhir_server_request: str) -> dict[str, Any]:
    """
    Update FHIR Server
    
    Parameters:
        server_id: Parameter: server_id
        update_fhir_server_request: JSON object with the following fields:
  - url (REQUIRED): New base URL for the FHIR server
  - name (optional): New name for the server
  - additional_properties (optional)
    
    Example JSON for parameters:
      update_fhir_server_request:
        {
          "url": "<url>"
        }
    
    Auto-generated from: servers_api.put_fhir_servers_by_server_id()
    """
    try:
        await ctx.info(f"Calling update_fhir_servers_by_server_id...")
        from api_client.models import UpdateFhirServerRequest
        # Convert JSON string to Pydantic model
        import json
        update_fhir_server_request_data = json.loads(update_fhir_server_request) if isinstance(update_fhir_server_request, str) else update_fhir_server_request
        update_fhir_server_request_obj = UpdateFhirServerRequest(**update_fhir_server_request_data)

        
        response = servers_api.put_fhir_servers_by_server_id(server_id=server_id, update_fhir_server_request=update_fhir_server_request_obj)
        
        # Convert response to dict if it has to_dict method
        if hasattr(response, 'to_dict'):
            result = response.to_dict()
        elif isinstance(response, list) and response and hasattr(response[0], 'to_dict'):
            result = [item.to_dict() for item in response]
        else:
            result = response
        
        await ctx.info(f"update_fhir_servers_by_server_id completed successfully")
        return {"result": result}
        
    except ApiException as e:
        error_msg = _format_api_error(e)
        await ctx.error(f"Failed to execute update_fhir_servers_by_server_id: {error_msg}")
        return {"error": error_msg, "status": e.status}
    except Exception as e:
        await ctx.error(f"Unexpected error in update_fhir_servers_by_server_id: {str(e)}")
        return {"error": str(e)}

@mcp.tool()
async def update_fhir_servers_by_server_id_mtls(ctx: Context, server_id: str, update_mtls_config_request: str) -> dict[str, Any]:
    """
    Update mTLS Configuration
    
    Parameters:
        server_id: Parameter: server_id
        update_mtls_config_request: JSON object with the following fields:
  - enabled (REQUIRED): Enable or disable mTLS for this server
  - additional_properties (optional)
    
    Example JSON for parameters:
      update_mtls_config_request:
        {
          "enabled": false
        }
    
    Auto-generated from: servers_api.put_fhir_servers_by_server_id_mtls()
    """
    try:
        await ctx.info(f"Calling update_fhir_servers_by_server_id_mtls...")
        from api_client.models import UpdateMtlsConfigRequest
        # Convert JSON string to Pydantic model
        import json
        update_mtls_config_request_data = json.loads(update_mtls_config_request) if isinstance(update_mtls_config_request, str) else update_mtls_config_request
        update_mtls_config_request_obj = UpdateMtlsConfigRequest(**update_mtls_config_request_data)

        
        response = servers_api.put_fhir_servers_by_server_id_mtls(server_id=server_id, update_mtls_config_request=update_mtls_config_request_obj)
        
        # Convert response to dict if it has to_dict method
        if hasattr(response, 'to_dict'):
            result = response.to_dict()
        elif isinstance(response, list) and response and hasattr(response[0], 'to_dict'):
            result = [item.to_dict() for item in response]
        else:
            result = response
        
        await ctx.info(f"update_fhir_servers_by_server_id_mtls completed successfully")
        return {"result": result}
        
    except ApiException as e:
        error_msg = _format_api_error(e)
        await ctx.error(f"Failed to execute update_fhir_servers_by_server_id_mtls: {error_msg}")
        return {"error": error_msg, "status": e.status}
    except Exception as e:
        await ctx.error(f"Unexpected error in update_fhir_servers_by_server_id_mtls: {str(e)}")
        return {"error": str(e)}


# SmartAppsApi tools
# ======================================================================

@mcp.tool()
async def delete_admin_smart_apps_by_client_id(ctx: Context, client_id: str) -> dict[str, Any]:
    """
    Delete SMART on FHIR Application
    
    Parameters:
        client_id: Parameter: client_id
    
    Auto-generated from: smart_apps_api.delete_admin_smart_apps_by_client_id()
    """
    try:
        await ctx.info(f"Calling delete_admin_smart_apps_by_client_id...")
        
        response = smart_apps_api.delete_admin_smart_apps_by_client_id(client_id=client_id)
        
        # Convert response to dict if it has to_dict method
        if hasattr(response, 'to_dict'):
            result = response.to_dict()
        elif isinstance(response, list) and response and hasattr(response[0], 'to_dict'):
            result = [item.to_dict() for item in response]
        else:
            result = response
        
        await ctx.info(f"delete_admin_smart_apps_by_client_id completed successfully")
        return {"result": result}
        
    except ApiException as e:
        error_msg = _format_api_error(e)
        await ctx.error(f"Failed to execute delete_admin_smart_apps_by_client_id: {error_msg}")
        return {"error": error_msg, "status": e.status}
    except Exception as e:
        await ctx.error(f"Unexpected error in delete_admin_smart_apps_by_client_id: {str(e)}")
        return {"error": str(e)}

@mcp.tool()
async def list_admin_smart_apps(ctx: Context) -> dict[str, Any]:
    """
    List SMART on FHIR Applications
    
    Auto-generated from: smart_apps_api.get_admin_smart_apps()
    """
    try:
        await ctx.info(f"Calling list_admin_smart_apps...")
        
        response = smart_apps_api.get_admin_smart_apps()
        
        # Convert response to dict if it has to_dict method
        if hasattr(response, 'to_dict'):
            result = response.to_dict()
        elif isinstance(response, list) and response and hasattr(response[0], 'to_dict'):
            result = [item.to_dict() for item in response]
        else:
            result = response
        
        await ctx.info(f"list_admin_smart_apps completed successfully")
        return {"result": result}
        
    except ApiException as e:
        error_msg = _format_api_error(e)
        await ctx.error(f"Failed to execute list_admin_smart_apps: {error_msg}")
        return {"error": error_msg, "status": e.status}
    except Exception as e:
        await ctx.error(f"Unexpected error in list_admin_smart_apps: {str(e)}")
        return {"error": str(e)}

@mcp.tool()
async def get_admin_smart_apps_by_client_id(ctx: Context, client_id: str) -> dict[str, Any]:
    """
    Get SMART on FHIR Application
    
    Parameters:
        client_id: Parameter: client_id
    
    Auto-generated from: smart_apps_api.get_admin_smart_apps_by_client_id()
    """
    try:
        await ctx.info(f"Calling get_admin_smart_apps_by_client_id...")
        
        response = smart_apps_api.get_admin_smart_apps_by_client_id(client_id=client_id)
        
        # Convert response to dict if it has to_dict method
        if hasattr(response, 'to_dict'):
            result = response.to_dict()
        elif isinstance(response, list) and response and hasattr(response[0], 'to_dict'):
            result = [item.to_dict() for item in response]
        else:
            result = response
        
        await ctx.info(f"get_admin_smart_apps_by_client_id completed successfully")
        return {"result": result}
        
    except ApiException as e:
        error_msg = _format_api_error(e)
        await ctx.error(f"Failed to execute get_admin_smart_apps_by_client_id: {error_msg}")
        return {"error": error_msg, "status": e.status}
    except Exception as e:
        await ctx.error(f"Unexpected error in get_admin_smart_apps_by_client_id: {str(e)}")
        return {"error": str(e)}

@mcp.tool()
async def create_admin_smart_apps(ctx: Context, create_smart_app_request: str) -> dict[str, Any]:
    """
    Create SMART on FHIR Application
    
    Parameters:
        create_smart_app_request: JSON object with the following fields:
  - clientId (REQUIRED): OAuth2 client ID (must be unique)
  - name (REQUIRED): Application name
  - description (optional): Application description
  - publicClient (optional): Whether this is a public client
  - redirectUris (optional): Allowed redirect URIs
  - webOrigins (optional): Allowed web origins
  - defaultScopes (optional): Default SMART scopes
  - optionalScopes (optional): Optional SMART scopes
  - smartVersion (optional): SMART App Launch version
  - fhirVersion (optional): FHIR version
  - appType (optional)
  - clientType (optional)
  - publicKey (optional): Public key for JWT authentication (PEM format)
  - jwksUri (optional): JWKS URI for JWT authentication
  - systemScopes (optional): System-level scopes for backend services
  - additional_properties (optional)
    
    Example JSON for parameters:
      create_smart_app_request:
        {
          "clientId": "<client_id>",
          "name": "Example Name"
        }
    
    Auto-generated from: smart_apps_api.post_admin_smart_apps()
    """
    try:
        await ctx.info(f"Calling create_admin_smart_apps...")
        from api_client.models import CreateSmartAppRequest
        # Convert JSON string to Pydantic model
        import json
        create_smart_app_request_data = json.loads(create_smart_app_request) if isinstance(create_smart_app_request, str) else create_smart_app_request
        create_smart_app_request_obj = CreateSmartAppRequest(**create_smart_app_request_data)

        
        response = smart_apps_api.post_admin_smart_apps(create_smart_app_request=create_smart_app_request_obj)
        
        # Convert response to dict if it has to_dict method
        if hasattr(response, 'to_dict'):
            result = response.to_dict()
        elif isinstance(response, list) and response and hasattr(response[0], 'to_dict'):
            result = [item.to_dict() for item in response]
        else:
            result = response
        
        await ctx.info(f"create_admin_smart_apps completed successfully")
        return {"result": result}
        
    except ApiException as e:
        error_msg = _format_api_error(e)
        await ctx.error(f"Failed to execute create_admin_smart_apps: {error_msg}")
        return {"error": error_msg, "status": e.status}
    except Exception as e:
        await ctx.error(f"Unexpected error in create_admin_smart_apps: {str(e)}")
        return {"error": str(e)}

@mcp.tool()
async def update_admin_smart_apps_by_client_id(ctx: Context, client_id: str, update_smart_app_request: str) -> dict[str, Any]:
    """
    Update SMART on FHIR Application
    
    Parameters:
        client_id: Parameter: client_id
        update_smart_app_request: JSON object with the following fields:
  - name (optional): Application name
  - description (optional): Application description
  - enabled (optional): Whether the app is enabled
  - redirectUris (optional): Allowed redirect URIs
  - webOrigins (optional): Allowed web origins
  - defaultScopes (optional): Default SMART scopes
  - optionalScopes (optional): Optional SMART scopes
  - smartVersion (optional): SMART App Launch version
  - fhirVersion (optional): FHIR version
  - additional_properties (optional)
    
    Example JSON for parameters:
      update_smart_app_request:
        {}
    
    Auto-generated from: smart_apps_api.put_admin_smart_apps_by_client_id()
    """
    try:
        await ctx.info(f"Calling update_admin_smart_apps_by_client_id...")
        from api_client.models import UpdateSmartAppRequest
        # Convert JSON string to Pydantic model
        import json
        update_smart_app_request_data = json.loads(update_smart_app_request) if isinstance(update_smart_app_request, str) else update_smart_app_request
        update_smart_app_request_obj = UpdateSmartAppRequest(**update_smart_app_request_data)

        
        response = smart_apps_api.put_admin_smart_apps_by_client_id(client_id=client_id, update_smart_app_request=update_smart_app_request_obj)
        
        # Convert response to dict if it has to_dict method
        if hasattr(response, 'to_dict'):
            result = response.to_dict()
        elif isinstance(response, list) and response and hasattr(response[0], 'to_dict'):
            result = [item.to_dict() for item in response]
        else:
            result = response
        
        await ctx.info(f"update_admin_smart_apps_by_client_id completed successfully")
        return {"result": result}
        
    except ApiException as e:
        error_msg = _format_api_error(e)
        await ctx.error(f"Failed to execute update_admin_smart_apps_by_client_id: {error_msg}")
        return {"error": error_msg, "status": e.status}
    except Exception as e:
        await ctx.error(f"Unexpected error in update_admin_smart_apps_by_client_id: {str(e)}")
        return {"error": str(e)}


# Generated 84 tools from 12 API classes

def main():
    """Run the FastMCP backend tools server."""
    mcp.run(transport="stdio")


if __name__ == "__main__":
    main()
